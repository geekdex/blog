<!DOCTYPE html><html lang="zh-CN" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="theme-color" media="(prefers-color-scheme: light)" content="#f7f7f7"><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1b1b1e"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"><meta name="viewport" content="width=device-width, user-scalable=no initial-scale=1, shrink-to-fit=no, viewport-fit=cover" ><meta name="generator" content="Jekyll v4.4.1" /><meta property="og:title" content="在 Debian 12 上完全手动安装 kubernetes v1.32.2" /><meta property="og:locale" content="zh_CN" /><meta name="description" content="基础环境准备" /><meta property="og:description" content="基础环境准备" /><link rel="canonical" href="https://blog.algs.tech/posts/tools_Fully-Manual-Installation-of-Kubernetes-v1.32.2-on-Debian-12.md-copy.html" /><meta property="og:url" content="https://blog.algs.tech/posts/tools_Fully-Manual-Installation-of-Kubernetes-v1.32.2-on-Debian-12.md-copy.html" /><meta property="og:site_name" content="极客开发者-博客" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2025-07-24T17:15:00+08:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="在 Debian 12 上完全手动安装 kubernetes v1.32.2" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2025-07-24T17:15:00+08:00","datePublished":"2025-07-24T17:15:00+08:00","description":"基础环境准备","headline":"在 Debian 12 上完全手动安装 kubernetes v1.32.2","mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.algs.tech/posts/tools_Fully-Manual-Installation-of-Kubernetes-v1.32.2-on-Debian-12.md-copy.html"},"url":"https://blog.algs.tech/posts/tools_Fully-Manual-Installation-of-Kubernetes-v1.32.2-on-Debian-12.md-copy.html"}</script><title>在 Debian 12 上完全手动安装 kubernetes v1.32.2 | 极客开发者-博客</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="极客开发者-博客"><meta name="application-name" content="极客开发者-博客"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="stylesheet" href="/assets/dist/fonts/main.css"><link rel="stylesheet" href="/assets/dist/bootstrap.min.css"><link rel="stylesheet" href="/assets/dist/fontawesome.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="/assets/lib/tocbot/tocbot.min.css"><link rel="stylesheet" href="/assets/dist/magnific-popup.min.css"> <script src="/assets/dist/jquery.min.js"></script> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get MODE_ATTR() { return "data-mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } static get ID() { return "mode-toggle"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } let self = this; /* always follow the system prefers */ this.sysDarkPrefers.addEventListener('change', () => { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.notify(); }); } /* constructor() */ get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode === ModeToggle.DARK_MODE; } get isLightMode() { return this.mode === ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer)) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } setDark() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_ATTR); sessionStorage.removeItem(ModeToggle.MODE_KEY); } /* Notify another plugins that the theme mode has changed */ notify() { window.postMessage({ direction: ModeToggle.ID, message: this.modeStatus }, "*"); } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } this.notify(); } /* flipMode() */ } /* ModeToggle */ const modeToggle = new ModeToggle(); </script><body data-topbar-visible="true"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" class="mx-auto"> <img src="/img/about/avatar.jpeg" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title"> <a href="/">极客开发者-博客</a></div><div class="site-subtitle font-italic">在探索未知与梦想的道路上，让我们拥有共同的称呼 -- 开发者</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>首页</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>分类</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tag ml-xl-3 mr-xl-3 unloaded"></i> <span>标签</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>归档</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info-circle ml-xl-3 mr-xl-3 unloaded"></i> <span>关于</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center align-items-center"> <button class="mode-toggle btn" aria-label="Switch Mode"> <i class="fas fa-adjust"></i> </button> <span class="icon-border"></span> <a href="https://github.com/geekdex" aria-label="github" target="_blank" rel="noopener noreferrer"> <i class="fab fa-github"></i> </a> <a href="javascript:location.href = 'mailto:' + ['pan.hy','foxmail.com'].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" > <i class="fas fa-rss"></i> </a></div></div><div id="topbar-wrapper"><div id="topbar" class="container d-flex align-items-center justify-content-between h-100 pl-3 pr-3 pl-md-4 pr-md-4"> <span id="breadcrumb"> <span> <a href="/"> 首页 </a> </span> <span>在 Debian 12 上完全手动安装 kubernetes v1.32.2</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> 文章</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="搜索..."> </span> <span id="search-cancel" >取消</span></div></div><div id="main-wrapper" class="d-flex justify-content-center"><div id="main" class="container pl-xl-4 pr-xl-4"><div class="row"><div id="core-wrapper" class="col-12 col-lg-11 col-xl-9 pr-xl-4"><div class="post pl-1 pr-1 pl-md-2 pr-md-2"><h1 data-toc-skip>在 Debian 12 上完全手动安装 kubernetes v1.32.2</h1><div class="post-meta text-muted"> <span> 发表于 <em class="" data-ts="1753348500" data-df="YYYY/MM/DD" data-toggle="tooltip" data-placement="bottom"> 2025/07/24 </em> </span> <span style="float: right;"> <a href="https://lab.aoco.tech/convert?url=https://raw.githubusercontent.com/geekdex/blog/refs/heads/main/_posts/2025-07-24-tools_Fully-Manual-Installation-of-Kubernetes-v1.32.2-on-Debian-12.md copy.md" class="view-source" target="_blank" style="color: #2a5caa; text-decoration: none; font-weight: 500;"> 查看Codelabs </a> &nbsp;|&nbsp; <a href="https://github.com/geekdex/blog/blob/main/_posts/2025-07-24-tools_Fully-Manual-Installation-of-Kubernetes-v1.32.2-on-Debian-12.md copy.md" class="view-source" target="_blank" style="color: #2a5caa; text-decoration: none; font-weight: 500;"> 查看源码 </a> </span><div class="d-flex justify-content-between"> <span> 作者 <em> <a href="https://blog.algs.tech">blog.algs.tech</a> </em> </span><div> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="12815 字"> <em>71 分钟</em>阅读</span></div></div></div><div class="post-content"><h2 id="基础环境准备"><span class="mr-2">基础环境准备</span><a href="#基础环境准备" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><h3 id="11-kubernetes集群组件概述"><span class="mr-2">1.1 kubernetes集群组件概述</span><a href="#11-kubernetes集群组件概述" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>Kubernetes 集群由 Master 节点（控制节点）和 Node 节点（工作节点）组成，各自包含以下核心组件：</p><h4 id="111-master节点"><span class="mr-2">1.1.1 Master节点</span><a href="#111-master节点" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><ol><li><strong>etcd</strong><ul><li>分布式键值存储数据库，保存集群的所有状态和配置数据（如 Pod、Service、Namespace 等）。<li>是 Kubernetes 的“唯一真实数据源”（Single Source of Truth）。</ul><li><strong>API Server（kube-apiserver）</strong><ul><li>集群的入口，提供 REST API，处理所有操作请求（如创建、更新、删除资源）。<li>负责与其他组件通信（如 kubelet、kube-scheduler 等）。</ul><li><strong>Scheduler（kube-scheduler）</strong><ul><li>监听未调度的 Pod，根据资源需求、节点负载等因素，将 Pod 分配到合适的 Node 上运行。</ul><li><strong>Controller Manager（kube-controller-manager）</strong><ul><li>运行一系列控制器，确保集群状态与期望一致。<li>核心控制器包括：<ul><li>Node Controller（监控节点状态）<li>Deployment Controller（管理副本数）<li>Service Controller（管理 Service 与 Endpoint）<li>其他控制器（如 ReplicaSet、Namespace 控制器等）。</ul></ul><li><strong>（可选）Cloud Controller Manager</strong><ul><li>当集群运行在公有云环境时，负责与云平台交互（如负载均衡、存储卷、节点管理）。<li>解耦 Kubernetes 与特定云厂商的代码。</ul></ol><h4 id="112-node-节点组件"><span class="mr-2">1.1.2 Node 节点组件</span><a href="#112-node-节点组件" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><ol><li><strong>kubelet</strong><ul><li>运行在每个 Node 上的“节点代理”，负责：<ul><li>与 Master 通信，接收 Pod 定义（通过 API Server）。<li>管理 Pod 生命周期（启动、停止、监控容器）。<li>上报节点状态（如资源使用、Pod 状态）到 Master。</ul></ul><li><strong>kube-proxy</strong><ul><li>维护节点上的网络规则，实现 Service 的抽象（如负载均衡、服务发现）。<li>通过 iptables/IPVS 或用户空间代理转发流量到 Pod。</ul><li><strong>容器运行时（Container Runtime）</strong><ul><li>负责运行容器的底层软件，如 Docker、containerd、CRI-O。<li>与 Kubernetes 通过 CRI（Container Runtime Interface）交互。</ul></ol><h3 id="12-集群主机规划"><span class="mr-2">1.2 集群主机规划</span><a href="#12-集群主机规划" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>假设我们只有3台主机，为了兼顾硬件条件限制而搭建高可用集群，以下是较为合理的集群软硬件规划：</p><div class="table-wrapper"><table><thead><tr><th>节点名称<th>IP<th>操作系统<th>配置<tbody><tr><td>k8s-101<td>192.168.122.101<td>Debian GNU/Linux 12 (bookworm)<td>内存:4G + SSD硬盘:30G + CPU:2核<tr><td>k8s-102<td>192.168.122.102<td>Debian GNU/Linux 12 (bookworm)<td>内存:4G + SSD硬盘:30G + CPU:2核<tr><td>k8s-103<td>192.168.122.103<td>Debian GNU/Linux 12 (bookworm)<td>内存:4G + SSD硬盘:30G + CPU:2核</table></div><p>这三台主机在集群中分别充当的角色如下：</p><div class="table-wrapper"><table><thead><tr><th>节点名称<th>etcd服务器<th>控制节点<th>工作节点<th>L4/L7代理<th>额外角色<tbody><tr><td>k8s-101<td>✓<td>✓<td>✕<td>✓<td>签发证书节点、主要控制节点<tr><td>k8s-102<td>✓<td>✓<td>✓<td>✓<td> <tr><td>k8s-103<td>✓<td>✓<td>✓<td>✕<td> </table></div><p>以上是在资源有限的情况下做的高可用资源分配，搭建集群的过程，其实就是把集群的各个软件组件合理安装到不同主机上，并且保证各个组件能正常工作。如果你的服务器资源充足，应当将组件独立部署到更多主机上，达到增强性能、可用性、可扩展性的目标，简化维护并增强安全性。</p><h3 id="13-设置hostsname"><span class="mr-2">1.3 设置hostsname</span><a href="#13-设置hostsname" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>在 192.168.122.101 执行以下命令</p><div class="language-bash highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre>hostnamectl set-hostname k8s-101
<span class="nb">cat</span> <span class="o">&gt;&gt;</span> /etc/hosts <span class="o">&lt;&lt;</span><span class="no">EOF</span><span class="sh">
192.168.122.101 k8s-101
</span><span class="no">EOF
</span></pre></table></code></div></div><p>在 <code class="language-plaintext highlighter-rouge">192.168.122.102</code> 执行以下命令</p><div class="language-bash highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre>hostnamectl set-hostname k8s-102
<span class="nb">cat</span> <span class="o">&gt;&gt;</span> /etc/hosts <span class="o">&lt;&lt;</span><span class="no">EOF</span><span class="sh">
192.168.122.102 k8s-102
</span><span class="no">EOF
</span></pre></table></code></div></div><p>在 <code class="language-plaintext highlighter-rouge">192.168.122.103</code> 执行以下命令</p><div class="language-bash highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre>hostnamectl set-hostname k8s-103
<span class="nb">cat</span> <span class="o">&gt;&gt;</span> /etc/hosts <span class="o">&lt;&lt;</span><span class="no">EOF</span><span class="sh">
192.168.122.103 k8s-103
</span><span class="no">EOF
</span></pre></table></code></div></div><h3 id="14-关闭交换分区"><span class="mr-2">1.4 关闭交换分区</span><a href="#14-关闭交换分区" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>kubernetes 默认不支持在启用交换分区的情况下运行，可以编辑 <code class="language-plaintext highlighter-rouge">/etc/fstab</code> 文件，注释掉或删除与交换分区相关的行。然后运行以下命令确保交换分区被禁用：</p><div class="language-bash highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>swapoff <span class="nt">-a</span>
</pre></table></code></div></div><h2 id="安装containerd"><span class="mr-2">安装containerd</span><a href="#安装containerd" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>containerd 的下载网址为<a href="https://containerd.io/downloads/">https://containerd.io/downloads/</a>，在撰写文章时（2025.02.15）最新版本是 v2.0.2，我们将其安装到所有主机上，并作为容器运行时环境，安装步骤如下</p><h3 id="21-安装-containerd"><span class="mr-2">2.1 安装 containerd</span><a href="#21-安装-containerd" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>从 <a href="https://github.com/containerd/containerd/releases">https://github.com/containerd/containerd/releases</a> 下载 <code class="language-plaintext highlighter-rouge">containerd-&lt;版本&gt;-&lt;操作系统&gt;-&lt;架构&gt;.tar.gz</code> 存档，验证其 sha256sum，并将其解压到 <code class="language-plaintext highlighter-rouge">/usr/local</code> 目录下</p><div class="language-shell highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
</pre><td class="rouge-code"><pre><span class="c"># 下载并解压</span>
<span class="nb">tar </span>Cxzvf /usr/local containerd-2.0.2-linux-amd64.tar.gz
<span class="c"># 创建并配置 containerd.service</span>
<span class="nb">mkdir</span> <span class="nt">-p</span> /usr/local/lib/systemd/system/
<span class="nb">cat</span> <span class="o">&gt;</span> /usr/local/lib/systemd/system/containerd.service <span class="o">&lt;&lt;</span><span class="no">EOF</span><span class="sh">
[Unit]
Description=containerd container runtime
Documentation=https://containerd.io
After=network.target local-fs.target dbus.service

[Service]
ExecStartPre=-/sbin/modprobe overlay
ExecStart=/usr/local/bin/containerd

Type=notify
Delegate=yes
KillMode=process
Restart=always
RestartSec=5

# Having non-zero Limit*s causes performance problems due to accounting overhead
# in the kernel. We recommend using cgroups to do container-local accounting.
LimitNPROC=infinity
LimitCORE=infinity

# Comment TasksMax if your systemd version does not supports it.
# Only systemd 226 and above support this version.
TasksMax=infinity
OOMScoreAdjust=-999

[Install]
WantedBy=multi-user.target
</span><span class="no">EOF
</span><span class="c"># 重新加载 systemd</span>
systemctl daemon-reload
<span class="c"># 启动并启用 containerd 开机启动</span>
systemctl <span class="nb">enable</span> <span class="nt">--now</span> containerd
</pre></table></code></div></div><h3 id="22-安装-runc"><span class="mr-2">2.2 安装 runc</span><a href="#22-安装-runc" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>runc 是一个轻量级的容器运行时工具，负责根据 OCI（Open Container Initiative） 规范创建和运行容器。containerd 依赖 runc 来实际启动和管理容器。</p><p>从 <a href="https://github.com/opencontainers/runc/releases">https://github.com/opencontainers/runc/releases</a> 下载 <code class="language-plaintext highlighter-rouge">runc.&lt;架构&gt;</code> 二进制文件，验证其 <code class="language-plaintext highlighter-rouge">sha256sum</code>，并将其安装为 <code class="language-plaintext highlighter-rouge">/usr/local/sbin/runc</code>。</p><div class="language-shell highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="c"># 安装</span>
<span class="nb">install</span> <span class="nt">-m</span> 755 runc.amd64 /usr/local/sbin/runc
</pre></table></code></div></div><p>该二进制文件是静态构建的，应该适用于任何对应架构的 <code class="language-plaintext highlighter-rouge">Linux</code> 发行版。</p><h3 id="23-安装-cni-插件"><span class="mr-2">2.3 安装 CNI 插件</span><a href="#23-安装-cni-插件" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>CNI（Container Network Interface） 插件用于配置容器的网络，包括分配 IP 地址、设置网络接口、配置路由等。从 <a href="https://github.com/containernetworking/plugins/releases">https://github.com/containernetworking/plugins/releases</a> 下载 <code class="language-plaintext highlighter-rouge">cni-plugins-&lt;操作系统&gt;-&lt;架构&gt;-&lt;版本&gt;.tgz</code> 存档，验证其 <code class="language-plaintext highlighter-rouge">sha256sum</code>，并将其解压到 <code class="language-plaintext highlighter-rouge">/opt/cni/bin</code> 目录下，操作过程如下</p><div class="language-shell highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="nb">mkdir</span> <span class="nt">-p</span> /opt/cni/bin
<span class="nb">tar </span>Cxzvf /opt/cni/bin cni-plugins-linux-amd64-v1.6.2.tgz
</pre></table></code></div></div><p>将 <code class="language-plaintext highlighter-rouge">/opt/cni/bin</code> 目录添加到 <code class="language-plaintext highlighter-rouge">$PATH</code> 中，执行以下命令追加到 <code class="language-plaintext highlighter-rouge">/etc/profile</code> 文件中</p><div class="language-shell highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="nb">echo</span> <span class="s1">'export PATH=$PATH:/opt/cni/bin'</span> <span class="o">&gt;&gt;</span> /etc/profile
<span class="nb">source</span> /etc/profile
</pre></table></code></div></div><p>创建 <code class="language-plaintext highlighter-rouge">CNI</code> 配置文件目录</p><div class="language-shell highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre><td class="rouge-code"><pre><span class="nb">mkdir</span> <span class="nt">-p</span> /etc/cni/net.d
<span class="nb">cat</span> <span class="o">&gt;</span> /etc/cni/net.d/10-mynet.conf <span class="o">&lt;&lt;</span><span class="no">EOF</span><span class="sh">
{
  "cniVersion": "0.4.0",
  "name": "mynet",
  "type": "bridge",
  "bridge": "cni0",
  "isGateway": true,
  "ipMasq": true,
  "ipam": {
    "type": "host-local",
    "subnet": "10.22.0.0/16",
    "routes": [
      { "dst": "0.0.0.0/0" }
    ]
  }
}
</span><span class="no">EOF
</span></pre></table></code></div></div><p>重启 <code class="language-plaintext highlighter-rouge">containerd</code></p><div class="language-shell highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>systemctl restart containerd
</pre></table></code></div></div><p>这些二进制文件是静态构建的，应该适用于任何对应架构的 <code class="language-plaintext highlighter-rouge">Linux</code> 发行版。</p><h3 id="24-使用命令行工具"><span class="mr-2">2.4 使用命令行工具</span><a href="#24-使用命令行工具" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p><code class="language-plaintext highlighter-rouge">containerd</code> 是一个强大的容器运行时，但它本身是一个守护进程，需要通过命令行工具（<code class="language-plaintext highlighter-rouge">CLI</code>）来交互。不同的 <code class="language-plaintext highlighter-rouge">CLI</code> 工具（如 <code class="language-plaintext highlighter-rouge">ctr</code>、<code class="language-plaintext highlighter-rouge">nerdctl</code>、<code class="language-plaintext highlighter-rouge">crictl</code>）是为了满足不同用户和场景的需求而设计的。以下是它们的区别和适用场景：</p><div class="table-wrapper"><table><thead><tr><th>工具<th>目标用户<th>功能特点<th>适用场景<tbody><tr><td><code class="language-plaintext highlighter-rouge">ctr</code><td><code class="language-plaintext highlighter-rouge">containerd</code> 开发者或高级用户<td><code class="language-plaintext highlighter-rouge">containerd</code> 自带的官方命令行工具，底层、简单、直接与 <code class="language-plaintext highlighter-rouge">containerd</code> 交互<td>开发和调试 <code class="language-plaintext highlighter-rouge">containerd</code><tr><td><code class="language-plaintext highlighter-rouge">nerdctl</code><td>普通用户和运维人员<td>类似 Docker 的体验，功能丰富<td>日常容器管理、生产环境<tr><td><code class="language-plaintext highlighter-rouge">crictl</code><td>Kubernetes 管理员和开发者<td>针对 CRI 设计，适合 Kubernetes 环境<td>调试 Kubernetes 节点和容器运行时</table></div><p>在这里，<code class="language-plaintext highlighter-rouge">nerdctl</code> 工具更适合我们的使用场景，因此选择 <code class="language-plaintext highlighter-rouge">nerdctl</code>。在 <a href="https://github.com/containerd/nerdctl/releases">https://github.com/containerd/nerdctl/releases</a> 下载对应的操作系统版本，在撰写这本文时 <code class="language-plaintext highlighter-rouge">nerdctl</code> 的版本是 <code class="language-plaintext highlighter-rouge">v2.0.3</code>，安装命令如下</p><div class="language-shell highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre>wget https://github.com/containerd/nerdctl/releases/download/v2.0.3/nerdctl-2.0.3-linux-amd64.tar.gz
<span class="nb">tar</span> <span class="nt">-zxvf</span> nerdctl-2.0.3-linux-amd64.tar.gz <span class="nt">-C</span> /usr/bin/ nerdctl
</pre></table></code></div></div><p>最后，加载 <code class="language-plaintext highlighter-rouge">nerdctl</code> 的 <code class="language-plaintext highlighter-rouge">Bash</code> 自动补全功能，并设置 <code class="language-plaintext highlighter-rouge">containerd</code> 默认的名称空间为 <code class="language-plaintext highlighter-rouge">k8s.io</code>，如下</p><div class="language-bash highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="c"># 追加配置</span>
<span class="nb">cat</span> <span class="o">&gt;&gt;</span> /etc/profile <span class="o">&lt;&lt;</span><span class="no">EOF</span><span class="sh">
source &lt;(nerdctl completion bash)
export CONTAINERD_NAMESPACE=k8s.io
</span><span class="no">EOF
</span><span class="c"># 让配置立即生效</span>
<span class="nb">source</span> /etc/profile
</pre></table></code></div></div><h3 id="25-配置-containerd"><span class="mr-2">2.5 配置 containerd</span><a href="#25-配置-containerd" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p><code class="language-plaintext highlighter-rouge">containerd</code> 默认配置文件在 <code class="language-plaintext highlighter-rouge">/etc/containerd/config.toml</code>，通过运行以下命令生成一个默认配置文件：</p><div class="language-shell highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="nb">mkdir</span> <span class="nt">-p</span> /etc/containerd
containerd config default <span class="o">&gt;</span> /etc/containerd/config.toml
</pre></table></code></div></div><p>重启 containerd</p><div class="language-shell highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>systemctl restart containerd
</pre></table></code></div></div><h2 id="签发ssl证书"><span class="mr-2">签发SSL证书</span><a href="#签发ssl证书" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><h3 id="31-安装证书工具"><span class="mr-2">3.1 安装证书工具</span><a href="#31-安装证书工具" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p><code class="language-plaintext highlighter-rouge">cfssl</code> 系列工具是 <code class="language-plaintext highlighter-rouge">Cloudflare</code> 提供的 <code class="language-plaintext highlighter-rouge">PKI/TLS</code> 工具，用于证书管理。可以在 <a href="https://github.com/cloudflare/cfssl">https://github.com/cloudflare/cfssl</a> 找到对应的信息，在撰写文章时版本是 <code class="language-plaintext highlighter-rouge">1.6.6</code>，我们下载对应操作系统的版本，安装到 <code class="language-plaintext highlighter-rouge">k8s-101</code> 这台主机，以 linux amd64 为例安装命令如下</p><div class="language-shell highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre>wget https://github.com/cloudflare/cfssl/releases/download/v1.6.5/cfssl_1.6.5_linux_amd64 <span class="nt">-o</span> /usr/local/bin/cfssl
wget https://github.com/cloudflare/cfssl/releases/download/v1.6.5/cfssljson_1.6.5_linux_amd64 <span class="nt">-o</span> /usr/local/bin/cfssljson
wget https://github.com/cloudflare/cfssl/releases/download/v1.6.5/cfssl-certinfo_1.6.5_linux_amd64 <span class="nt">-o</span> /usr/local/bin/cfssl-certinfo
<span class="nb">chmod </span>a+x /usr/local/bin/cfssl<span class="k">*</span>
</pre></table></code></div></div><p>以下是它们的简要功能</p><div class="table-wrapper"><table><thead><tr><th>工具<th>功能<tbody><tr><td>cfssl<td>核心工具，用于证书生成和管理<tr><td>cfssl-json<td>辅助工具，用于解析 JSON 输出<tr><td>cfssl-certinfo<td>用于查看证书详细信息</table></div><h3 id="32-k8s所需证书概述"><span class="mr-2">3.2 k8s所需证书概述</span><a href="#32-k8s所需证书概述" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>在 <code class="language-plaintext highlighter-rouge">Kubernetes</code> 集群中，我们需要为集群中的各个组件生成证书，以实现安全通信和身份验证。下图展示了 <code class="language-plaintext highlighter-rouge">Kubernetes</code> 所需的主要证书</p><p><a href="/img/tools/k8s_pki.png" class="popup img-link "><img data-src="/img/tools/k8s_pki.png" alt="k8s证书" class="lazyload" data-proofer-ignore></a></p><p>我们将在 <code class="language-plaintext highlighter-rouge">k8s-101</code> 生成的各个证书存放到 <code class="language-plaintext highlighter-rouge">/etc/kubernetes/pki</code> 里，并同步到其他主机上。</p><h3 id="33-搭建ca"><span class="mr-2">3.3 搭建CA</span><a href="#33-搭建ca" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p><code class="language-plaintext highlighter-rouge">CA</code> 是证书的签发机构的简称，所有子证书的签发证书的前提是有一个签发机构，下文我们搭建自己的签发机构。</p><p>使用以下命令生成 <code class="language-plaintext highlighter-rouge">CA</code> 配置</p><div class="language-shell highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre><td class="rouge-code"><pre><span class="nb">mkdir</span> <span class="nt">-p</span> /etc/kubernetes/pki
<span class="nb">cat</span> <span class="o">&gt;</span> /etc/kubernetes/pki/ca-config.json <span class="o">&lt;&lt;</span><span class="no">EOF</span><span class="sh">
{
    "signing": {
        "default": {
            "expiry": "175200h"
        },
        "profiles": {
            "www": {
                "expiry": "175200h",
                "usages": [
                    "signing",
                    "key encipherment",
                    "server auth",
                    "client auth"
                ]
            }
        }
    }
}
</span><span class="no">EOF
</span></pre></table></code></div></div><p>使用以下命令生成 CA 请求文件</p><div class="language-shell highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre><td class="rouge-code"><pre><span class="nb">cat</span> <span class="o">&gt;</span> /etc/kubernetes/pki/ca-csr.json <span class="o">&lt;&lt;</span><span class="no">EOF</span><span class="sh">
{
    "CN": "kubernetes",
    "key": {
        "algo": "rsa",
        "size": 2048
    },
    "names": [
        {
            "C": "CN",
            "L": "Guangzhou",
            "ST": "Guangdong",
            "O": "kubernetes",
            "OU": "system"
        }
    ],
    "ca": {
        "expiry": "175200h"
    }
}
</span><span class="no">EOF
</span></pre></table></code></div></div><p>证书根字段备注如下</p><div class="table-wrapper"><table><thead><tr><th>字段<th>描述<th>示例或说明<tbody><tr><td><code class="language-plaintext highlighter-rouge">CN</code><td>证书名称（Common Name），一般使用域名<td>example.com<tr><td><code class="language-plaintext highlighter-rouge">key</code><td>定义证书类型，<code class="language-plaintext highlighter-rouge">algo</code> 为加密类型，<code class="language-plaintext highlighter-rouge">size</code> 为加密长度<td>algo: RSA, size: 2048<tr><td><code class="language-plaintext highlighter-rouge">names</code><td>定义证书的通用名称，可以有多个条目<td> <tr><td><code class="language-plaintext highlighter-rouge">CN</code><td>Common Name，一般使用域名<td>example.com<tr><td><code class="language-plaintext highlighter-rouge">C</code><td>Country Code，申请单位所属国家，只能是两个字母的国家码<td>CN（中国）<tr><td><code class="language-plaintext highlighter-rouge">ST</code><td>State or Province，省份名称或自治区名称<td>Beijing<tr><td><code class="language-plaintext highlighter-rouge">L</code><td>Locality，城市或自治州名<td>Beijing<tr><td><code class="language-plaintext highlighter-rouge">O</code><td>Organization name，组织名称、公司名称<td>Example Inc.<tr><td><code class="language-plaintext highlighter-rouge">OU</code><td>Organization Unit Name，组织单位名称、公司部门<td>IT Department<tr><td><code class="language-plaintext highlighter-rouge">ca.expiry</code><td>代表有效时间，175200h 对应 20 年<td>175200h</table></div><p>最后使用以下命令生成CA自签名根证书</p><div class="language-shell highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>cfssl gencert <span class="nt">-initca</span> ca-csr.json | cfssljson <span class="nt">-bare</span> ca
</pre></table></code></div></div><p>最后一个参数指定了证书文件名，最后生成以下三个文件</p><ul><li><code class="language-plaintext highlighter-rouge">ca.csr</code>: 证书签名申请（Certificate Signing Request）文件<li><code class="language-plaintext highlighter-rouge">ca.pem</code>: ca公钥证书<li><code class="language-plaintext highlighter-rouge">ca-key.pem</code>: ca私钥证书</ul><p>生成的三个文件是根证书包含的内容。后续，我们给各个服务颁发证书的时候，都基于 <code class="language-plaintext highlighter-rouge">CA</code> 根证书来颁发。</p><h3 id="34-签发证书"><span class="mr-2">3.4 签发证书</span><a href="#34-签发证书" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li>etcd</ul><p>定义证书信息如下</p><div class="language-shell highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
</pre><td class="rouge-code"><pre><span class="nb">cat</span> <span class="o">&gt;</span> /etc/kubernetes/pki/etcd-csr.json <span class="o">&lt;&lt;</span><span class="no">EOF</span><span class="sh">
{
    "CN": "etcd",
    "hosts": [
        "127.0.0.1",
        "192.168.122.101",
        "192.168.122.102",
        "192.168.122.103"
    ],
    "key": {
        "algo": "rsa",
        "size": 2048
    },
    "names": [{
        "C": "CN",
        "ST": "Guangdong",
        "L": "Guangzhou",
        "O": "kubernetes",
        "OU": "system"
    }]
}
</span><span class="no">EOF
</span></pre></table></code></div></div><p>支持的主机列表对应本机以及所有 <code class="language-plaintext highlighter-rouge">etcd</code> 节点。使用以下命令生成证书</p><div class="language-shell highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>cfssl gencert <span class="nt">-ca</span><span class="o">=</span>ca.pem <span class="nt">-ca-key</span><span class="o">=</span>ca-key.pem <span class="nt">-config</span><span class="o">=</span>ca-config.json <span class="nt">-profile</span><span class="o">=</span>www etcd-csr.json | cfssljson <span class="nt">-bare</span> etcd
</pre></table></code></div></div><ul><li>kube-apiserver</ul><p><code class="language-plaintext highlighter-rouge">k8s</code> 的其他组件跟 <code class="language-plaintext highlighter-rouge">apiserver</code> 要进行双向 <code class="language-plaintext highlighter-rouge">TLS（mTLS）</code> 认证，所以 <code class="language-plaintext highlighter-rouge">apiserver</code> 需要有自己的证书，以下定义证书申请文件</p><div class="language-shell highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
</pre><td class="rouge-code"><pre><span class="nb">cat</span> <span class="o">&gt;</span> /etc/kubernetes/pki/apiserver-csr.json <span class="o">&lt;&lt;</span><span class="no">EOF</span><span class="sh">
{
    "CN": "apiserver",
    "key": {
        "algo": "rsa",
        "size": 2048
    },
    "hosts": [
        "127.0.0.1",
        "10.96.0.1",
        "192.168.122.100",
        "192.168.122.101",
        "192.168.122.102",
        "192.168.122.103",
        "kubernetes",
        "kubernetes.default",
        "kubernetes.default.svc",
        "kubernetes.default.svc.cluster",
        "kubernetes.default.svc.cluster.local"
    ],
    "names": [{
        "C": "CN",
        "ST": "Guangdong",
        "L": "Guangzhou",
        "O": "kubernetes",
        "OU": "system"
    }]
}
</span><span class="no">EOF
</span></pre></table></code></div></div><p>该证书后续被 <code class="language-plaintext highlighter-rouge">kubernetes master</code> 集群使用，需要将 <code class="language-plaintext highlighter-rouge">master</code> 节点的 IP 都填上，同时还需要填写 <code class="language-plaintext highlighter-rouge">service</code> 网络的第一个IP（后续计划使用<code class="language-plaintext highlighter-rouge">10.96.0.0 255.255.0.0</code> 网段作为 <code class="language-plaintext highlighter-rouge">service</code> 网络，因此加上 <code class="language-plaintext highlighter-rouge">10.96.0.1</code>），后续可能加到集群里的IP也需要都填写上去。最后使用以下命令生成证书</p><div class="language-shell highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>cfssl gencert <span class="nt">-ca</span><span class="o">=</span>ca.pem <span class="nt">-ca-key</span><span class="o">=</span>ca-key.pem <span class="nt">-config</span><span class="o">=</span>ca-config.json <span class="nt">-profile</span><span class="o">=</span>www apiserver-csr.json | cfssljson <span class="nt">-bare</span> apiserver
</pre></table></code></div></div><p>– kube-controller-manager</p><p><code class="language-plaintext highlighter-rouge">controller-manager</code> 需要跟 <code class="language-plaintext highlighter-rouge">apiserver</code> 进行 <code class="language-plaintext highlighter-rouge">mTLS</code> 认证，定义证书申请文件如下</p><div class="language-shell highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
</pre><td class="rouge-code"><pre><span class="nb">cat</span> <span class="o">&gt;</span> /etc/kubernetes/pki/controller-manager-csr.json <span class="o">&lt;&lt;</span><span class="no">EOF</span><span class="sh">
{
  "CN": "system:kube-controller-manager",
  "key": {
    "algo": "rsa",
    "size": 2048
  },
   "hosts": [
     "127.0.0.1",
     "192.168.122.100",
     "192.168.122.101",
     "192.168.122.102",
     "192.168.122.103"
    ],
  "names": [
    {
      "C": "CN",
      "ST": "Guangdong",
      "L": "Guangzhou",
      "O": "system:kube-controller-manager",
      "OU": "system"
    }
  ]
}
</span><span class="no">EOF
</span></pre></table></code></div></div><p><code class="language-plaintext highlighter-rouge">hosts</code> 列表包含所有 <code class="language-plaintext highlighter-rouge">kube-controller-manager</code> 节点 IP；CN 为 <code class="language-plaintext highlighter-rouge">system:kube-controller-manager</code>，O 为 <code class="language-plaintext highlighter-rouge">system:kube-controller-manager</code>，k8s里内置的<code class="language-plaintext highlighter-rouge">ClusterRoleBindings system:kube-controller-manager</code> 授权 <code class="language-plaintext highlighter-rouge">kube-controller-manager</code> 所需的权限。后面组件证书都做类似操作。生成证书命令如下</p><div class="language-shell highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>cfssl gencert <span class="nt">-ca</span><span class="o">=</span>ca.pem <span class="nt">-ca-key</span><span class="o">=</span>ca-key.pem <span class="nt">-config</span><span class="o">=</span>ca-config.json <span class="nt">-profile</span><span class="o">=</span>www controller-manager-csr.json | cfssljson <span class="nt">-bare</span> controller-manager
</pre></table></code></div></div><ul><li>kube-scheduler</ul><p><code class="language-plaintext highlighter-rouge">kube-scheduler</code> 需要跟 <code class="language-plaintext highlighter-rouge">apiserver</code> 进行 <code class="language-plaintext highlighter-rouge">mTLS</code> 认证，生成证书申请文件如下</p><div class="language-shell highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
</pre><td class="rouge-code"><pre><span class="nb">cat</span> <span class="o">&gt;</span> /etc/kubernetes/pki/scheduler-csr.json <span class="o">&lt;&lt;</span><span class="no">EOF</span><span class="sh">
{
  "CN": "system:kube-scheduler",
  "key": {
    "algo": "rsa",
    "size": 2048
  },
   "hosts": [
     "127.0.0.1",
     "192.168.122.100",
     "192.168.122.101",
     "192.168.122.102",
     "192.168.122.101"
    ],
  "names": [
    {
      "C": "CN",
      "ST": "Guangdong",
      "L": "Guangzhou",
      "O": "system:kube-scheduler",
      "OU": "system"
    }
  ]
}
</span><span class="no">EOF
</span></pre></table></code></div></div><p><code class="language-plaintext highlighter-rouge">kubernetes</code> 内置的 <code class="language-plaintext highlighter-rouge">ClusterRoleBindings system:kube-scheduler</code> 将授权 <code class="language-plaintext highlighter-rouge">kube-scheduler</code> 所需的权限。生成证书命令如下</p><div class="language-shell highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>cfssl gencert <span class="nt">-ca</span><span class="o">=</span>ca.pem <span class="nt">-ca-key</span><span class="o">=</span>ca-key.pem <span class="nt">-config</span><span class="o">=</span>ca-config.json <span class="nt">-profile</span><span class="o">=</span>www scheduler-csr.json | cfssljson <span class="nt">-bare</span> scheduler
</pre></table></code></div></div><ul><li>kube-proxy</ul><p><code class="language-plaintext highlighter-rouge">kube-proxy</code> 需要跟 <code class="language-plaintext highlighter-rouge">apiserver</code> 进行 mTLS 认证，生成证书申请请求文件如下</p><div class="language-shell highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre><td class="rouge-code"><pre><span class="nb">cat</span> <span class="o">&gt;</span> /etc/kubernetes/pki/proxy-csr.json <span class="o">&lt;&lt;</span><span class="no">EOF</span><span class="sh">
{
  "CN": "system:kube-proxy",
  "key": {
    "algo": "rsa",
    "size": 2048
  },
  "names": [
    {
      "C": "CN",
      "ST": "Guangdong",
      "L": "Guangzhou",
      "O": "kubernetes",
      "OU": "system"
    }
  ]
}
</span><span class="no">EOF
</span></pre></table></code></div></div><p>生成证书</p><div class="language-shell highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>cfssl gencert <span class="nt">-ca</span><span class="o">=</span>ca.pem <span class="nt">-ca-key</span><span class="o">=</span>ca-key.pem <span class="nt">-config</span><span class="o">=</span>ca-config.json <span class="nt">-profile</span><span class="o">=</span>www proxy-csr.json | cfssljson <span class="nt">-bare</span> proxy
</pre></table></code></div></div><ul><li>管理员admin能用的证书</ul><p>创建证书信息</p><div class="language-shell highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre><td class="rouge-code"><pre><span class="nb">cat</span> <span class="o">&gt;</span> /etc/kubernetes/pki/admin-csr.json <span class="o">&lt;&lt;</span> <span class="no">EOF</span><span class="sh">
{
  "CN": "admin",
  "key": {
    "algo": "rsa",
    "size": 2048
  },
  "names": [
    {
      "C": "CN",
      "ST": "Guangzhou",
      "L": "Guangdong",
      "O": "system:masters",
      "OU": "system"
    }
  ]
}
</span><span class="no">EOF
</span></pre></table></code></div></div><p>生成证书</p><div class="language-shell highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>cfssl gencert <span class="nt">-ca</span><span class="o">=</span>ca.pem <span class="nt">-ca-key</span><span class="o">=</span>ca-key.pem <span class="nt">-config</span><span class="o">=</span>ca-config.json <span class="nt">-profile</span><span class="o">=</span>www admin-csr.json | cfssljson <span class="nt">-bare</span> admin
</pre></table></code></div></div><h3 id="35-同步证书"><span class="mr-2">3.5 同步证书</span><a href="#35-同步证书" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>生成证书之后，将证书目录<code class="language-plaintext highlighter-rouge">/etc/kubernetes/pki</code>同步到其他主机。</p><h2 id="安装etcd"><span class="mr-2">安装etcd</span><a href="#安装etcd" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>我们将使用 <code class="language-plaintext highlighter-rouge">k8s-101</code>、<code class="language-plaintext highlighter-rouge">k8s-102</code>、<code class="language-plaintext highlighter-rouge">k8s-103</code> 这三台主机搭建ectd集群。在撰写此文档时（2425.02.18），etcd最新稳定版本是 <code class="language-plaintext highlighter-rouge">3.5.18</code>，可以从 <a href="https://github.com/etcd-io/etcd/releases/">https://github.com/etcd-io/etcd/releases/</a> 这个链接下载对应的安装包。</p><h3 id="41-etcd启动参数"><span class="mr-2">4.1 etcd启动参数</span><a href="#41-etcd启动参数" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>常见参数说明说下</p><div class="table-wrapper"><table><thead><tr><th>参数<th>对应环境变量<th>说明<tbody><tr><td>–name<td>ETCD_NAME<td>当前etcd的唯一名称，要保证和其他节点不冲突<tr><td>–data-dir<td>ETCD_DATA_DIR<td>指定etcd存储数据的存储位置<tr><td>–listen-peer-urls<td>ETCD_LISTEN_PEER_URLS<td>端对端的通信url，包含主机地址和端口号，指定当前etcd和其他节点etcd通信时的服务地址和端口。<tr><td>–listen-client-urls<td>ETCD_LISTEN_CLIENT_URLS<td>指定当前etcd接收客户端指令的地址和端口，在这里的客户端我们指的是k8s集群的master节点<tr><td>–initial-advertise-peer-urls<td>ETCD_INITIAL_ADVERTISE_PEER_URLS<td>指定etcd广播端口，当前etcd会将数据同步到其他节点，通过2380端口发送<tr><td>–advertise-client-urls<td>ETCD_ADVERTISE_CLIENT_URLS<td>给客户端通告的端口<tr><td>–initial-cluster<td>ETCD_INITIAL_CLUSTER<td>定义etcd集群中所有节点的名称和IP，以及通信端口<tr><td>–initial-cluster-token<td>ETCD_INITIAL_CLUSTER_TOKEN<td>定义etcd中的token，所有节点的token必须保持一致<tr><td>–initial-cluster-state<td>ETCD_INITIAL_CLUSTER_STATE<td>定义etcd集群的状态，new代表新建集群，existing代表加入现有集群</table></div><h3 id="42-创建数据目录"><span class="mr-2">4.2 创建数据目录</span><a href="#42-创建数据目录" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>先创建etcd默认的配置文件目录和数据目录</p><div class="language-bash highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="nb">mkdir</span> <span class="nt">-p</span> /var/lib/etcd/
</pre></table></code></div></div><p>安装到<code class="language-plaintext highlighter-rouge">/opt</code>目录，后续的k8s集群组件我们将都安装在此</p><div class="language-shell highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="c"># 解压</span>
<span class="nb">tar</span> <span class="nt">-zxvf</span> etcd-v3.5.18-linux-amd64.tar.gz
<span class="c"># 将etc移到/opt目录，并修改etcd目录名</span>
<span class="nb">mv </span>etcd-v3.5.18-linux-amd64/ /opt/etcd-v3.5.18
<span class="c"># 创建etcd软链接</span>
<span class="nb">ln</span> <span class="nt">-s</span> /opt/etcd-v3.5.18 /opt/etcd
</pre></table></code></div></div><h3 id="43-创建etcd启动脚本"><span class="mr-2">4.3 创建etcd启动脚本</span><a href="#43-创建etcd启动脚本" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>我们先在etcd目录编写启动脚本<code class="language-plaintext highlighter-rouge">/opt/etcd/startup.sh</code>，如下</p><div class="language-shell highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre><td class="rouge-code"><pre><span class="c">#!/bin/bash</span>
./etcd <span class="se">\</span>
  <span class="nt">--name</span><span class="o">=</span><span class="s2">"etcd-server-101"</span> <span class="se">\</span>
  <span class="nt">--data-dir</span><span class="o">=</span><span class="s2">"/var/lib/etcd/"</span> <span class="se">\</span>
  <span class="nt">--listen-peer-urls</span><span class="o">=</span><span class="s2">"https://192.168.122.101:2380"</span> <span class="se">\</span>
  <span class="nt">--listen-client-urls</span><span class="o">=</span><span class="s2">"https://192.168.122.101:2379,http://127.0.0.1:2379"</span> <span class="se">\</span>
  <span class="nt">--initial-advertise-peer-urls</span><span class="o">=</span><span class="s2">"https://192.168.122.101:2380"</span> <span class="se">\</span>
  <span class="nt">--advertise-client-urls</span><span class="o">=</span><span class="s2">"https://192.168.122.101:2379"</span> <span class="se">\</span>
  <span class="nt">--initial-cluster</span><span class="o">=</span><span class="s2">"etcd-server-101=https://192.168.122.101:2380,etcd-server-102=https://192.168.122.102:2380,etcd-server-103=https://192.168.122.103:2380"</span> <span class="se">\</span>
  <span class="nt">--initial-cluster-token</span><span class="o">=</span><span class="s2">"etcd-cluster"</span> <span class="se">\</span>
  <span class="nt">--initial-cluster-state</span><span class="o">=</span><span class="s2">"new"</span> <span class="se">\</span>
  <span class="nt">--cert-file</span><span class="o">=</span><span class="s2">"/etc/kubernetes/pki/etcd.pem"</span> <span class="se">\</span>
  <span class="nt">--key-file</span><span class="o">=</span><span class="s2">"/etc/kubernetes/pki/etcd-key.pem"</span> <span class="se">\</span>
  <span class="nt">--trusted-ca-file</span><span class="o">=</span><span class="s2">"/etc/kubernetes/pki/ca.pem"</span> <span class="se">\</span>
  <span class="nt">--peer-cert-file</span><span class="o">=</span><span class="s2">"/etc/kubernetes/pki/etcd.pem"</span> <span class="se">\</span>
  <span class="nt">--peer-key-file</span><span class="o">=</span><span class="s2">"/etc/kubernetes/pki/etcd-key.pem"</span> <span class="se">\</span>
  <span class="nt">--peer-trusted-ca-file</span><span class="o">=</span><span class="s2">"/etc/kubernetes/pki/ca.pem"</span> <span class="se">\</span>
  <span class="nt">--peer-client-cert-auth</span> <span class="se">\</span>
  <span class="nt">--client-cert-auth</span>
</pre></table></code></div></div><p>给启动脚本添加权限</p><div class="language-shell highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="nb">chmod</span> +x /opt/etcd/startup.sh
</pre></table></code></div></div><h3 id="44-使用supervisor来启动etcd"><span class="mr-2">4.4 使用supervisor来启动etcd</span><a href="#44-使用supervisor来启动etcd" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>现在我们要安装supervisor，用于管理etcd服务，后续的k8s相关组件，我们都用supervisor来管理</p><div class="language-shell highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="c"># 安装supervisor</span>
apt <span class="nb">install </span>supervisor <span class="nt">-y</span>
<span class="c"># 启动supervisor</span>
systemctl start supervisor
<span class="c"># 让superivisor开机自启</span>
systemctl <span class="nb">enable </span>supervisor
</pre></table></code></div></div><p>添加etcd的supervisor进程维护脚本<code class="language-plaintext highlighter-rouge">/etc/supervisor/conf.d/etcd-server.conf</code>，添加以下内容</p><div class="language-ini highlighter-rouge"><div class="code-header"> <span data-label-text="Ini"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre><td class="rouge-code"><pre><span class="nn">[program:etcd-server-101]</span><span class="w">
</span><span class="py">directory</span><span class="p">=</span><span class="s">/opt/etcd</span>
<span class="py">command</span><span class="p">=</span><span class="s">/opt/etcd/startup.sh</span>
<span class="py">numprocs</span><span class="p">=</span><span class="s">1</span>
<span class="py">autostart</span><span class="p">=</span><span class="s">true</span>
<span class="py">autorestart</span><span class="p">=</span><span class="s">true</span>
<span class="py">startsecs</span><span class="p">=</span><span class="s">30</span>
<span class="py">startretries</span><span class="p">=</span><span class="s">3</span>
<span class="py">exitcodes</span><span class="p">=</span><span class="s">0,2</span>
<span class="py">stopsignal</span><span class="p">=</span><span class="s">QUIT</span>
<span class="py">stopwaitsecs</span><span class="p">=</span><span class="s">10</span>
<span class="py">user</span><span class="p">=</span><span class="s">root</span>
<span class="py">redirect_stderr</span><span class="p">=</span><span class="s">true</span>
<span class="py">stdout_logfile</span><span class="p">=</span><span class="s">/data/logs/supervisor/etcd.stdout.log</span>
<span class="py">stdout_logfile_maxbytes</span><span class="p">=</span><span class="s">64MB</span>
<span class="py">stdout_logfile_backups</span><span class="p">=</span><span class="s">4</span>
<span class="py">stdout_capture_maxbytes</span><span class="p">=</span><span class="s">1MB</span>
<span class="py">stdout_event_enabled</span><span class="p">=</span><span class="s">false</span>
</pre></table></code></div></div><blockquote><p>注意：在不同的主机上使用不同的服务名称，这样好辨别，如k8s-101使用<code class="language-plaintext highlighter-rouge">etcd-server-101</code>，如k8s-102使用<code class="language-plaintext highlighter-rouge">etcd-server-102</code></p></blockquote><p>supervisor相关参数：</p><ul><li><code class="language-plaintext highlighter-rouge">program</code>: 程序名称<li><code class="language-plaintext highlighter-rouge">directory</code>: 脚本目录<li><code class="language-plaintext highlighter-rouge">command</code>: 启动的命令<li><code class="language-plaintext highlighter-rouge">numprocs</code>: 启动的进程数<li><code class="language-plaintext highlighter-rouge">autostart</code>: 是否开启自动启动<li><code class="language-plaintext highlighter-rouge">autorestart</code>: 是否自动重启<li><code class="language-plaintext highlighter-rouge">startsecs</code>: 启动之后多少时间后判定为已起来<li><code class="language-plaintext highlighter-rouge">startretries</code>: 重启次数<li><code class="language-plaintext highlighter-rouge">exitcodes</code>: 退出的code<li><code class="language-plaintext highlighter-rouge">stopsignal</code>: 停止信号<li><code class="language-plaintext highlighter-rouge">stopwaitsecs</code>: 停止等待的时间<li><code class="language-plaintext highlighter-rouge">redirect_stderr</code>: 是否重定向标准输出<li><code class="language-plaintext highlighter-rouge">stdout_logfile</code>: 进程标准输出内容写入文件<li><code class="language-plaintext highlighter-rouge">stdout_logfile_maxbytes</code>: stdout_logfile文件做log滚动时，单个stdout_logfile文件的最大字节数，默认50M，设置为0则认为不做log滚动方式<li><code class="language-plaintext highlighter-rouge">stdout_logfile_backups</code>: stdout_logfile备份文件个数，默认为10<li><code class="language-plaintext highlighter-rouge">stdout_capture_maxbytes</code>: 当进程处于stdout capture mode模式的时候，写入capture FIFO的最大字节数限制，默认为0，此时认为stdout capture mode模式关闭<li><code class="language-plaintext highlighter-rouge">stdout_event_enabled</code>: 如果设置为true，在进程写入标准文件是会发起PROCESS_LOG_STDOUT</ul><p>更新supervisod配置文件</p><div class="language-shell highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="c"># 创建supervisor日志目录</span>
<span class="nb">mkdir</span> <span class="nt">-p</span> /data/logs/supervisor/
<span class="c"># 更新supervisod配置</span>
supervisorctl update
</pre></table></code></div></div><p>通过<code class="language-plaintext highlighter-rouge">supervisorctl status</code>查询supervisord状态，看到如下内容，代表supervisor正常运行</p><div class="language-shell highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre>root@debian:/opt/etcd# supervisorctl status
etcd-server-101                  RUNNING   pid 85297, <span class="nb">uptime </span>0:04:38
</pre></table></code></div></div><p>此时，我们再使用<code class="language-plaintext highlighter-rouge">netstat -luntp | grep etcd</code>查看网络服务端口，看到如下信息代表etcd已经正常启动</p><div class="language-shell highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre>root@debian:/opt/etcd# netstat <span class="nt">-luntp</span> | <span class="nb">grep </span>etcd
tcp        0      0 192.168.122.101:2379      0.0.0.0:<span class="k">*</span>               LISTEN      85298/./etcd
tcp        0      0 127.0.0.1:2379          0.0.0.0:<span class="k">*</span>               LISTEN      85298/./etcd
tcp        0      0 192.168.122.101:2380      0.0.0.0:<span class="k">*</span>               LISTEN      85298/./etcd
</pre></table></code></div></div><h3 id="45-集群验证"><span class="mr-2">4.5 集群验证</span><a href="#45-集群验证" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>为了方便直接调用<code class="language-plaintext highlighter-rouge">etcdctl</code>命令，我们还可以创建其软连接</p><div class="language-bash highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="nb">ln</span> <span class="nt">-s</span> /opt/etcd/etcdctl /usr/local/bin/etcdctl
</pre></table></code></div></div><p>我们在任意节点使用etcdctl命令检查集群状态，需要注意的是，要确切指定证书的位置</p><div class="language-shell highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>etcdctl <span class="nt">--cacert</span><span class="o">=</span><span class="s2">"/etc/kubernetes/pki/ca.pem"</span> <span class="nt">--cert</span><span class="o">=</span><span class="s2">"/etc/kubernetes/pki/etcd.pem"</span> <span class="nt">--key</span><span class="o">=</span><span class="s2">"/etc/kubernetes/pki/etcd-key.pem"</span> <span class="nt">--endpoints</span><span class="o">=</span><span class="s2">"https://192.168.122.101:2379,https://192.168.122.102:2379,https://192.168.122.103:2379"</span> endpoint status <span class="nt">--write-out</span><span class="o">=</span>table
</pre></table></code></div></div><p>如果看到如下输出，代表 ectd 集群搭建成功</p><div class="language-bash highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre>+------------------------------+------------------+---------+---------+-----------+------------+-----------+------------+--------------------+--------+
| ENDPOINT                     | ID               | VERSION | DB SIZE | IS LEADER | IS LEARNER | RAFT TERM | RAFT INDEX | RAFT APPLIED INDEX | ERRORS |
+------------------------------+------------------+---------+---------+-----------+------------+-----------+------------+--------------------+--------+
| https://192.168.122.101:2379 | c8815bb4b21730b3 | 3.5.18  | 311 kB  | <span class="nb">true</span>      | <span class="nb">false</span>      | 3         | 37628      | 37628              |        |
| https://192.168.122.102:2379 | f30299e8a0b43b4d | 3.5.18  | 311 kB  | <span class="nb">false</span>     | <span class="nb">false</span>      | 3         | 37628      | 37628              |        |
| https://192.168.122.103:2379 | 61c90f737ccf2682 | 3.5.18  | 311 kB  | <span class="nb">false</span>     | <span class="nb">false</span>      | 3         | 37628      | 37628              |        |
+------------------------------+------------------+---------+---------+-----------+------------+-----------+------------+--------------------+--------+
</pre></table></code></div></div><p>为了验证etcd集群是否正常工作，我们还可以现在<code class="language-plaintext highlighter-rouge">k8s-101</code>设置一个值，如下</p><div class="language-bash highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>etcdctl put name lixiaoming123
</pre></table></code></div></div><p>再通过<code class="language-plaintext highlighter-rouge">k8s-102</code>和<code class="language-plaintext highlighter-rouge">k8s-103</code>去读取值，如果正常取到，代表etcd集群正常工作，如下命令</p><div class="language-bash highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>etcdctl get name
</pre></table></code></div></div><p>如果需要了解<code class="language-plaintext highlighter-rouge">etcdctl</code>这个指令的更多用法，使用<code class="language-plaintext highlighter-rouge">--help</code>参数即可查看。</p><h2 id="将kubernetes二进制安装包解压到系统中"><span class="mr-2">将kubernetes二进制安装包解压到系统中</span><a href="#将kubernetes二进制安装包解压到系统中" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>在撰写这个文档时，kubernetes最新稳定版本为<code class="language-plaintext highlighter-rouge">v1.32.2</code>，所以这里也采用这个版本。通过 <a href="https://kubernetes.io/zh-cn/releases/">https://kubernetes.io/zh-cn/releases/</a> 下载最新的对应操作系统的稳定版本。</p><p>我们下载好对应的 “Server Binarie” 之后，在所有k8s主机上执行安装，如下步骤</p><div class="language-shell highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="c"># 解压安装包</span>
<span class="nb">tar</span> <span class="nt">-zxvf</span> kubernetes-server-linux-amd64.tar.gz
<span class="c"># 将安装包移到/opt目录下并根据版本重命名</span>
<span class="nb">mv </span>kubernetes /opt/kubernetes-v1.32.2
<span class="c"># 创建软连接</span>
<span class="nb">ln</span> <span class="nt">-s</span> /opt/kubernetes-v1.32.2/ /opt/kubernetes
</pre></table></code></div></div><p>在k8s二进制安装目录里包含了k8s源码包，还包含k8s核心组件的docker镜像，因为我们的核心服务不运行在容器里，所以可以删除掉，操作过程如下</p><div class="language-shell highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="c"># 进入k8s目录</span>
<span class="nb">cd</span> /opt/kubernetes
<span class="c"># 删除源代码</span>
<span class="nb">rm </span>kubernetes-src.tar.gz
<span class="c"># 删除二进制文件目录下以tar作为名称后缀的docker镜像包</span>
<span class="nb">rm</span> <span class="nt">-rf</span> server/bin/<span class="k">*</span>.tar
</pre></table></code></div></div><h2 id="安装apiserver"><span class="mr-2">安装apiserver</span><a href="#安装apiserver" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>搭建好etcd数据库集群之后，我们就可以安装apiserver组件了，在所有主机上安装apiserver，以下是具体的安装过程。</p><h3 id="61-创建kubelet授权用户"><span class="mr-2">6.1 创建kubelet授权用户</span><a href="#61-创建kubelet授权用户" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>因为后面要配置kubelet的bootstrap认证，即kubelet启动时自动创建CSR请求，这里需要在apiserver上开启token的认证。所以先在master上生成一个随机值作为token。下面在一台主机操作即可</p><div class="language-shell highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="c"># 创建证书目录</span>
openssl rand <span class="nt">-hex</span> 10
</pre></table></code></div></div><p>假设生成的token为<code class="language-plaintext highlighter-rouge">88c916f382dc619a6bca</code>，把这个token写入到一个文件里，这里写入到 <code class="language-plaintext highlighter-rouge">/etc/kubernetes/bb.csv</code>，如下</p><div class="language-bash highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="nb">cat</span> <span class="o">&gt;</span> /etc/kubernetes/bb.csv <span class="o">&lt;&lt;</span><span class="no">EOF</span><span class="sh">
88c916f382dc619a6bca,kubelet-bootstrap,10001,"system:node-bootstrapper"
</span><span class="no">EOF
</span></pre></table></code></div></div><p>这里第二列定义了一个用户名kubelet-bootstrap，后面在配置kubelet时会为此用户授权。创建好该文件后，同步到其他主机。</p><h3 id="62-启动apiser服务"><span class="mr-2">6.2 启动apiser服务</span><a href="#62-启动apiser服务" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><h4 id="621-创建启动脚本"><span class="mr-2">6.2.1 创建启动脚本</span><a href="#621-创建启动脚本" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>在apiserver二进制文件目录创建<code class="language-plaintext highlighter-rouge">/opt/kubernetes/server/bin/kube-apiserver.sh</code>启动脚本文件，写入以下内容</p><div class="language-bash highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
</pre><td class="rouge-code"><pre><span class="c">#!/bin/bash</span>
./kube-apiserver <span class="se">\</span>
    <span class="nt">--v</span><span class="o">=</span>2 <span class="se">\</span>
    <span class="nt">--logtostderr</span><span class="o">=</span><span class="nb">true</span> <span class="se">\</span>
    <span class="nt">--allow-privileged</span><span class="o">=</span><span class="nb">true</span> <span class="se">\</span>
    <span class="nt">--bind-address</span><span class="o">=</span><span class="s2">"192.168.122.101"</span> <span class="se">\</span>
    <span class="nt">--secure-port</span><span class="o">=</span><span class="s2">"6443"</span> <span class="se">\</span>
    <span class="nt">--token-auth-file</span><span class="o">=</span><span class="s2">"/etc/kubernetes/bb.csv"</span> <span class="se">\</span>
    <span class="nt">--advertise-address</span><span class="o">=</span><span class="s2">"192.168.122.101"</span> <span class="se">\</span>
    <span class="nt">--service-cluster-ip-range</span><span class="o">=</span><span class="s2">"10.96.0.0/16"</span> <span class="se">\</span>
    <span class="nt">--service-node-port-range</span><span class="o">=</span><span class="s2">"30000-60000"</span> <span class="se">\</span>
    <span class="nt">--etcd-servers</span><span class="o">=</span><span class="s2">"https://192.168.122.101:2379,https://192.168.122.102:2379,https://192.168.122.103:2379"</span> <span class="se">\</span>
    <span class="nt">--etcd-cafile</span><span class="o">=</span><span class="s2">"/etc/kubernetes/pki/ca.pem"</span> <span class="se">\</span>
    <span class="nt">--etcd-certfile</span><span class="o">=</span><span class="s2">"/etc/kubernetes/pki/etcd.pem"</span> <span class="se">\</span>
    <span class="nt">--etcd-keyfile</span><span class="o">=</span><span class="s2">"/etc/kubernetes/pki/etcd-key.pem"</span> <span class="se">\</span>
    <span class="nt">--client-ca-file</span><span class="o">=</span><span class="s2">"/etc/kubernetes/pki/ca.pem"</span> <span class="se">\</span>
    <span class="nt">--tls-cert-file</span><span class="o">=</span><span class="s2">"/etc/kubernetes/pki/apiserver.pem"</span> <span class="se">\</span>
    <span class="nt">--tls-private-key-file</span><span class="o">=</span><span class="s2">"/etc/kubernetes/pki/apiserver-key.pem"</span> <span class="se">\</span>
    <span class="nt">--kubelet-client-certificate</span><span class="o">=</span><span class="s2">"/etc/kubernetes/pki/apiserver.pem"</span> <span class="se">\</span>
    <span class="nt">--kubelet-client-key</span><span class="o">=</span><span class="s2">"/etc/kubernetes/pki/apiserver-key.pem"</span> <span class="se">\</span>
    <span class="nt">--service-account-key-file</span><span class="o">=</span><span class="s2">"/etc/kubernetes/pki/ca-key.pem"</span> <span class="se">\</span>
    <span class="nt">--service-account-signing-key-file</span><span class="o">=</span><span class="s2">"/etc/kubernetes/pki/ca-key.pem"</span> <span class="se">\</span>
    <span class="nt">--service-account-issuer</span><span class="o">=</span><span class="s2">"https://kubernetes.default.svc.cluster.local"</span> <span class="se">\</span>
    <span class="nt">--kubelet-preferred-address-types</span><span class="o">=</span><span class="s2">"InternalIP,ExternalIP,Hostname"</span> <span class="se">\</span>
    <span class="nt">--enable-admission-plugins</span><span class="o">=</span><span class="s2">"NamespaceLifecycle,LimitRanger,ServiceAccount,DefaultStorageClass,DefaultTolerationSeconds,NodeRestriction,ResourceQuota"</span> <span class="se">\</span>
    <span class="nt">--authorization-mode</span><span class="o">=</span><span class="s2">"Node,RBAC"</span> <span class="se">\</span>
    <span class="nt">--enable-bootstrap-token-auth</span><span class="o">=</span><span class="nb">true</span>
    <span class="c">#--requestheader-client-ca-file=/etc/kubernetes/pki/front-proxy-ca.pem  \</span>
    <span class="c">#--proxy-client-cert-file=/etc/kubernetes/pki/front-proxy-client.pem  \</span>
    <span class="c">#--proxy-client-key-file=/etc/kubernetes/pki/front-proxy-client-key.pem  \</span>
    <span class="c">#--requestheader-allowed-names=aggregator  \</span>
    <span class="c">#--requestheader-group-headers=X-Remote-Group  \</span>
    <span class="c">#--requestheader-extra-headers-prefix=X-Remote-Extra-  \</span>
    <span class="c">#--requestheader-username-headers=X-Remote-User</span>
</pre></table></code></div></div><p>赋予执行权限</p><div class="language-shell highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="nb">chmod</span> +x /opt/kubernetes/server/bin/kube-apiserver.sh
</pre></table></code></div></div><p>上面注释的部分是配置聚合层的，本环境里没有启用聚合层所以这些选项被注释了，如果配置了聚合层的话，则需要把#取消。相关参数说明</p><ul><li><code class="language-plaintext highlighter-rouge">--v</code>：日志输出级别<li><code class="language-plaintext highlighter-rouge">--logtostderr</code>：将输出记录到标准日志，而不是文件，默认是true<li><code class="language-plaintext highlighter-rouge">--allow-privileged</code>：是否使用超级管理员权限创建容器，默认为false<li><code class="language-plaintext highlighter-rouge">--bind-address</code>：绑定的IP地址，如果没有指定地址（0.0.0.0或者::），默认是 0.0.0.0，代表所有的网卡都在监听服务<li><code class="language-plaintext highlighter-rouge">--secure-port</code>：参数指定的端口号对应监听的IP地址<li><code class="language-plaintext highlighter-rouge">--token-auth-file</code>：该文件用于指定api-server颁发证书的token授权<li><code class="language-plaintext highlighter-rouge">--advertise-address</code>：向集群广播的ip地址，这个ip地址必须能被集群的其他节点访问，如果不指定，将使用–bind-address，如果不指定–bind-addres，将使用默认网卡<li><code class="language-plaintext highlighter-rouge">--service-cluster-ip-range</code>：创建service时，使用的虚拟网段<li><code class="language-plaintext highlighter-rouge">--service-node-port-range</code>：创建service时，服务端口使用的端口范围（默认 30000-32767）<li><code class="language-plaintext highlighter-rouge">--etcd-cafile</code>：访问etcd时使用，ectd的ca文件<li><code class="language-plaintext highlighter-rouge">--etcd-certfile</code>：访问etcd时使用，ectd的证书文件<li><code class="language-plaintext highlighter-rouge">--etcd-servers</code>：各个etcd节点的IP和端口号<li><code class="language-plaintext highlighter-rouge">--etcd-keyfile</code>：访问etcd时使用，ectd的证书私钥文件<li><code class="language-plaintext highlighter-rouge">--client-ca-file</code>：访问apiserver时使用，客户端ca文件<li><code class="language-plaintext highlighter-rouge">--tls-cert-file</code>：访问apiserver时使用，tls证书文件<li><code class="language-plaintext highlighter-rouge">--tls-private-key-file</code>：访问apiserver时使用，tls证书私钥文件<li><code class="language-plaintext highlighter-rouge">--kubelet-client-certificate</code>：访问kubelet时使用，客户端证书路径<li><code class="language-plaintext highlighter-rouge">--kubelet-client-key</code>：访问kubelet时使用，客户端证书私钥<li><code class="language-plaintext highlighter-rouge">--service-account-key-file</code>：包含 PEM 编码的 x509 RSA 或 ECDSA 私钥或公钥，用来检查 ServiceAccount 的令牌<li><code class="language-plaintext highlighter-rouge">--service-account-signing-key-file</code>：指向包含当前服务账号令牌发放者的私钥的文件路径。 此发放者使用此私钥来签署所发放的 ID 令牌<li><code class="language-plaintext highlighter-rouge">--service-account-issuer</code>：服务账户令牌发放者的身份标识<li><code class="language-plaintext highlighter-rouge">--enable-admission-plugins</code>：允许使用的插件<li><code class="language-plaintext highlighter-rouge">--authorization-mode</code>：授权模式<li><code class="language-plaintext highlighter-rouge">--enable-bootstrap-token-auth</code>：是否使用token的方式来自动颁发证书，如果主机节点比较多的时候，手动颁发证书可能不太现实，可以使用基于token的方式自动颁发证书</ul><p>以上是我们在启动apiserver的时候常用的参数，apiserver具有很多参数，很多参数也有默认值，可以<code class="language-plaintext highlighter-rouge">./kube-apiserver --hep</code>命令查看更多的帮助。</p><h4 id="622-使用supervisor运行"><span class="mr-2">6.2.2 使用supervisor运行</span><a href="#622-使用supervisor运行" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>创建supervisor配置文件<code class="language-plaintext highlighter-rouge">/etc/supervisor/conf.d/kube-apiserver.conf</code></p><div class="language-ini highlighter-rouge"><div class="code-header"> <span data-label-text="Ini"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre><td class="rouge-code"><pre><span class="nn">[program:kube-apiserver-160]</span><span class="w">
</span><span class="py">directory</span><span class="p">=</span><span class="s">/opt/kubernetes/server/bin</span>
<span class="py">command</span><span class="p">=</span><span class="s">/opt/kubernetes/server/bin/kube-apiserver.sh</span>
<span class="py">numprocs</span><span class="p">=</span><span class="s">1</span>
<span class="py">autostart</span><span class="p">=</span><span class="s">true</span>
<span class="py">autorestart</span><span class="p">=</span><span class="s">true</span>
<span class="py">startsecs</span><span class="p">=</span><span class="s">30</span>
<span class="py">startretries</span><span class="p">=</span><span class="s">3</span>
<span class="py">exitcodes</span><span class="p">=</span><span class="s">0,2</span>
<span class="py">stopsignal</span><span class="p">=</span><span class="s">QUIT</span>
<span class="py">stopwaitsecs</span><span class="p">=</span><span class="s">10</span>
<span class="py">user</span><span class="p">=</span><span class="s">root</span>
<span class="py">redirect_stderr</span><span class="p">=</span><span class="s">true</span>
<span class="py">stdout_logfile</span><span class="p">=</span><span class="s">/data/logs/supervisor/apiserver.stdout.log</span>
<span class="py">stdout_logfile_maxbytes</span><span class="p">=</span><span class="s">64MB</span>
<span class="py">stdout_logfile_backups</span><span class="p">=</span><span class="s">4</span>
<span class="py">stdout_capture_maxbytes</span><span class="p">=</span><span class="s">1MB</span>
<span class="py">stdout_event_enabled</span><span class="p">=</span><span class="s">false</span>
</pre></table></code></div></div><p>更新supervisor服务</p><div class="language-shell highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>supervisorctl update
</pre></table></code></div></div><p>再使用<code class="language-plaintext highlighter-rouge">supervisorctl status</code>命令查看apiserver启动状态，如果显示如下内容，代表正常服务</p><p>此时，还可以使用<code class="language-plaintext highlighter-rouge">netstat -luntp | grep kube-api</code>命令查看网络服务的端口是否正常，如果正常，将返回如下内容</p><h2 id="搭建l4层负载均衡"><span class="mr-2">搭建L4层负载均衡</span><a href="#搭建l4层负载均衡" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>负载均衡是网络层的一种机制，它将请求分发到后端服务器，从而实现高可用和高性能。负载均衡器通常包含一个或多个负载均衡器，每个负载均衡器负责将请求分发到后端服务器。负载均衡器通常使用TCP或UDP协议进行通信，并通过网络层（如TCP或UDP）将请求分发到后端服务器。负载均衡器通常使用轮询、权重、会话保持等功能来优化请求分发。</p><p>现在，我们需要在<code class="language-plaintext highlighter-rouge">k8s-101</code>和<code class="language-plaintext highlighter-rouge">k8s-102</code>上安装nginx作为反向代理服务且两个服务实现负载均衡，再使用keepalived保证高可用性</p><h3 id="71-安装nginx"><span class="mr-2">7.1 安装nginx</span><a href="#71-安装nginx" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p><code class="language-plaintext highlighter-rouge">k8s-101</code>在安装harbor时已经安装过，需要继续在<code class="language-plaintext highlighter-rouge">k8s-102</code>上安装</p><div class="language-bash highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre><td class="rouge-code"><pre><span class="c"># 安装依赖</span>
apt <span class="nb">install</span> <span class="nt">-y</span> gcc make libpcre3-dev libssl-dev zlib1g-dev
<span class="c"># 下载代码</span>
wget https://nginx.org/download/nginx-1.26.3.tar.gz
<span class="c"># 解压文件</span>
<span class="nb">tar</span> <span class="nt">-zxvf</span> nginx-1.26.3.tar.gz
<span class="c"># 进入源码目录</span>
<span class="nb">cd </span>nginx-1.26.3
<span class="c"># 配置编译参数，--prefix参数指定安装目录</span>
./configure <span class="se">\</span>
<span class="nt">--prefix</span><span class="o">=</span>/usr/local/nginx-1.26.3 <span class="se">\</span>
<span class="nt">--with-stream</span> <span class="se">\</span>
<span class="nt">--with-http_stub_status_module</span> <span class="se">\</span>
<span class="nt">--with-http_ssl_module</span> <span class="nt">--with-http_v2_module</span> <span class="se">\</span>
<span class="nt">--error-log-path</span><span class="o">=</span>/data/logs/nginx/error.log <span class="se">\</span>
<span class="nt">--http-log-path</span><span class="o">=</span>/data/logs/nginx/access.log
<span class="c"># 编译并安装</span>
make <span class="o">&amp;&amp;</span> make <span class="nb">install</span>
<span class="c"># 设置链接</span>
<span class="nb">ln</span> <span class="nt">-s</span> /usr/local/nginx-1.26.3 /usr/local/nginx
<span class="nb">ln</span> <span class="nt">-s</span> /usr/local/nginx/sbin/nginx /usr/local/bin/nginx
</pre></table></code></div></div><h3 id="72-配置nginx"><span class="mr-2">7.2 配置nginx</span><a href="#72-配置nginx" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>安装完成之后，我们需要两台机的nginx的配置文件<code class="language-plaintext highlighter-rouge">/usr/local/nginx/conf/nginx.conf</code>的<code class="language-plaintext highlighter-rouge">http</code>节点旁边添加四层反向代码规则，将7443端口的流量使用负载均衡的方式转发到3台主机的6443端口上</p><div class="language-shell highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre><td class="rouge-code"><pre><span class="c"># 设置代理规则</span>
stream <span class="o">{</span>
    upstream kube-apiserver <span class="o">{</span>
        server 192.168.122.101:6443  <span class="nv">max_fails</span><span class="o">=</span>3  <span class="nv">fail_timeout</span><span class="o">=</span>30s<span class="p">;</span>
        server 192.168.122.102:6443  <span class="nv">max_fails</span><span class="o">=</span>3  <span class="nv">fail_timeout</span><span class="o">=</span>30s<span class="p">;</span>
        server 192.168.122.103:6443  <span class="nv">max_fails</span><span class="o">=</span>3  <span class="nv">fail_timeout</span><span class="o">=</span>30s<span class="p">;</span>
    <span class="o">}</span>
    server <span class="o">{</span>
        listen  7443<span class="p">;</span>
        proxy_connect_timeout  2s<span class="p">;</span>
        proxy_timeout  900s<span class="p">;</span>
        proxy_pass kube-apiserver<span class="p">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p>在两台主机上配置好规则之后，通过<code class="language-plaintext highlighter-rouge">nginx -t</code>命令检查配置结果，如果输出以下内容代表配置正确</p><div class="language-shell highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre>nginx: the configuration file /etc/nginx/nginx.conf syntax is ok
nginx: configuration file /etc/nginx/nginx.conf <span class="nb">test </span>is successful
</pre></table></code></div></div><p>配置成功之后，启动nginx，如下指令</p><div class="language-bash highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="c"># 启动ginx，k8s-101主机使用 nginx -s reload重新加载配置即可</span>
nginx
</pre></table></code></div></div><p>要让你手动编译安装的 Nginx 实现开机自启，你可以通过以下几种方式来完成（基于常见的 Linux 系统，如 Ubuntu、CentOS 等）。</p><h3 id="73-使用systemd设置nginx开机自启"><span class="mr-2">7.3 使用systemd设置nginx开机自启</span><a href="#73-使用systemd设置nginx开机自启" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li>创建 Nginx 的 Systemd 服务文件</ul><p>在 <code class="language-plaintext highlighter-rouge">/etc/systemd/system/</code> 目录下创建一个 <code class="language-plaintext highlighter-rouge">nginx.service</code> 文件：</p><div class="language-bash highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>vim /etc/systemd/system/nginx.service
</pre></table></code></div></div><ul><li>添加以下内容到服务文件中</ul><div class="language-ini highlighter-rouge"><div class="code-header"> <span data-label-text="Ini"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre><td class="rouge-code"><pre><span class="nn">[Unit]</span><span class="w">
</span><span class="py">Description</span><span class="p">=</span><span class="s">The NGINX HTTP and reverse proxy server</span>
<span class="py">After</span><span class="p">=</span><span class="s">network.target</span>
<span class="w">
</span><span class="nn">[Service]</span><span class="w">
</span><span class="py">ExecStart</span><span class="p">=</span><span class="s">/usr/local/nginx/sbin/nginx</span>
<span class="py">ExecReload</span><span class="p">=</span><span class="s">/usr/local/nginx/sbin/nginx -s reload</span>
<span class="py">ExecStop</span><span class="p">=</span><span class="s">/usr/local/nginx/sbin/nginx -s quit</span>
<span class="py">PIDFile</span><span class="p">=</span><span class="s">/usr/local/nginx/logs/nginx.pid</span>
<span class="py">Restart</span><span class="p">=</span><span class="s">on-failure</span>
<span class="py">Type</span><span class="p">=</span><span class="s">forking</span>
<span class="w">
</span><span class="nn">[Install]</span><span class="w">
</span><span class="py">WantedBy</span><span class="p">=</span><span class="s">multi-user.target</span>
</pre></table></code></div></div><ul><li>保存并刷新 <code class="language-plaintext highlighter-rouge">systemd</code> 配置</ul><div class="language-bash highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>systemctl daemon-reload
</pre></table></code></div></div><ul><li>设置 Nginx 开机自启并立即启动</ul><div class="language-bash highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>systemctl <span class="nb">enable </span>nginx <span class="nt">--now</span>
</pre></table></code></div></div><h3 id="74-安装keepalived"><span class="mr-2">7.4 安装keepalived</span><a href="#74-安装keepalived" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>Keepalived 的虚拟 IP 通过 VRRP 协议在多个服务器间切换，确保服务高可用性和负载均衡。这个虚拟 IP 是 Keepalived 配置的 IP 地址，不属于任何特定服务器，而是由主服务器持有，主服务器故障时切换到备用服务器。我们将使用keepalived实现代理服务器的高可用，以下是安装过程</p><div class="language-shell highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>apt <span class="nb">install </span>keepalived <span class="nt">-y</span>
</pre></table></code></div></div><p>在两台主机的创建<code class="language-plaintext highlighter-rouge">/etc/keepalived/check_port.sh</code>脚本文件，添加以下内容</p><div class="language-shell highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre><span class="c">#!/bin/bash</span>
<span class="nv">CHK_PORT</span><span class="o">=</span><span class="nv">$1</span>
<span class="k">if</span> <span class="o">[</span> <span class="nt">-n</span> <span class="s2">"</span><span class="nv">$CHK_PORT</span><span class="s2">"</span> <span class="o">]</span><span class="p">;</span> <span class="k">then
    </span><span class="nv">PORT_PROCESS</span><span class="o">=</span><span class="sb">`</span>ss <span class="nt">-lnt</span>|grep <span class="nv">$CHK_PORT</span>|wc <span class="nt">-l</span><span class="sb">`</span>
    <span class="k">if</span> <span class="o">[</span> <span class="nv">$PORT_PROCESS</span> <span class="nt">-eq</span> 0 <span class="o">]</span><span class="p">;</span> <span class="k">then
        </span><span class="nb">echo</span> <span class="s2">"Port </span><span class="nv">$CHK_PORT</span><span class="s2"> Is Not Used, End"</span>
        <span class="nb">exit </span>1
    <span class="k">fi
else
    </span><span class="nb">echo</span> <span class="s2">"Check Port Cant Be Empty!"</span>
    <span class="nb">exit </span>1
<span class="k">fi</span>
</pre></table></code></div></div><p>添加执行权限</p><div class="language-shell highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="nb">chmod</span> +x /etc/keepalived/check_port.sh
</pre></table></code></div></div><p>以上的操作就准备好keepalived的基础环境了，接下来我们使用<code class="language-plaintext highlighter-rouge">k8s-101</code>这台主机作为主节点，使用<code class="language-plaintext highlighter-rouge">k8s-102</code>作为重节点，进行以下配置</p><p><code class="language-plaintext highlighter-rouge">k8s-101</code>作为主节点，修改<code class="language-plaintext highlighter-rouge">/etc/keepalived/keepalived.conf</code>配置文件如下</p><div class="language-shell highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre><td class="rouge-code"><pre><span class="o">!</span> Configuration File <span class="k">for </span>keepalived

<span class="c"># 全局配置global_defs {</span>
   router_id 192.168.122.101  <span class="c"># 当前服务器的唯一标识，通常用 IP 地址或主机名}</span>

<span class="c"># 定义健康检查脚本vrrp_script check_nginx {</span>
    script <span class="s2">"/etc/keepalived/check_port.sh 7443"</span>  <span class="c"># 检查端口 7443 是否在监听的脚本    interval 2  # 每隔 2 秒执行一次脚本    weight -20  # 如果脚本检查失败，当前服务器的优先级降低 20</span>
<span class="o">}</span>

<span class="c"># 定义一个 VRRP 实例vrrp_instance VI_1 {</span>
    state MASTER  <span class="c"># 当前服务器的初始状态是 MASTER（主服务器）    interface enp1s0  # 绑定虚拟 IP 的网络接口    virtual_router_id 251  # VRRP 实例的唯一 ID，范围是 1-255</span>
    priority 100  <span class="c"># 当前服务器的优先级，数值越大优先级越高    advert_int 1  # 每隔 1 秒发送一次 VRRP 通告    mcast_src_ip 192.168.122.101  # 发送 VRRP 通告的源 IP 地址    nopreempt  # 如果主服务器挂了又恢复，不会抢占虚拟 IP</span>

    <span class="c"># 认证配置    authentication {</span>
        auth_type PASS  <span class="c"># 认证类型为密码认证        auth_pass 1111  # 认证密码    }</span>

    <span class="c"># 虚拟 IP 地址配置    virtual_ipaddress {</span>
        192.168.122.100  <span class="c"># 虚拟 IP 地址，主服务器会持有这个 IP</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><code class="language-plaintext highlighter-rouge">k8s-102</code>作为从节点，修改<code class="language-plaintext highlighter-rouge">/etc/keepalived/keepalived.conf</code>配置文件如下</p><div class="language-shell highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
</pre><td class="rouge-code"><pre><span class="o">!</span> Configuration File <span class="k">for </span>keepalived

global_defs <span class="o">{</span>
   router_id 192.168.122.102
<span class="o">}</span>

vrrp_script check_nginx <span class="o">{</span>
    script <span class="s2">"/etc/keepalived/check_port.sh 7443"</span>
    interval 2
    weight <span class="nt">-20</span>
<span class="o">}</span>

vrrp_instance VI_1 <span class="o">{</span>
    state BACKUP
    interface enp1s0
    virtual_router_id 251
    priority 90
    advert_int 1
    mcast_src_ip 192.168.122.101
    nopreempt

    authentication <span class="o">{</span>
        auth_type PASS
        auth_pass 1111
    <span class="o">}</span>
    virtual_ipaddress <span class="o">{</span>
        192.168.122.100
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p>启动服务</p><div class="language-shell highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="c"># 重启服务</span>
systemctl restart keepalived
<span class="c"># 设置服务为开机自启</span>
systemctl <span class="nb">enable </span>keepalived
</pre></table></code></div></div><p>需要注意的是，<code class="language-plaintext highlighter-rouge">interface</code>参数对应的是真实的主机网卡名称，<code class="language-plaintext highlighter-rouge">virtual_router_id</code>参数需要在同一个虚拟IP的前提下，设置需与主机一个网段的IP。</p><h3 id="75-验证"><span class="mr-2">7.5 验证</span><a href="#75-验证" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>通过<code class="language-plaintext highlighter-rouge">ping 192.168.122.100</code>的方式进行验证，如果有正常返回，代表keepalived运行正常。</p><p>为了验证 Keepalived 的高可用性，可以手动模拟主服务器故障，观察虚拟 IP 是否切换到备用服务器。</p><ul><li>（1）停止主服务器的 Keepalived 服务</ul><p>在主服务器上执行：</p><div class="language-bash highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>systemctl stop keepalived
</pre></table></code></div></div><ul><li>（2）检查备用服务器的虚拟 IP</ul><p>在备用服务器上执行：</p><div class="language-bash highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>ip addr show
</pre></table></code></div></div><p>检查虚拟 IP 是否绑定到备用服务器的网卡。</p><ul><li>（3）恢复主服务器的 Keepalived 服务</ul><p>在主服务器上执行：</p><div class="language-bash highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>systemctl start keepalived
</pre></table></code></div></div><p>再次检查虚拟 IP 是否切换回主服务器。如果以上操作正常，则说明 Keepalived 的高可用性已经实现，否则需要检查安装过程以及 Keepalived 的配置文件，确保所有参数设置正确。</p><h2 id="安装controller-manager"><span class="mr-2">安装controller-manager</span><a href="#安装controller-manager" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><h3 id="81-创建kubectl链接"><span class="mr-2">8.1 创建kubectl链接</span><a href="#81-创建kubectl链接" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p><code class="language-plaintext highlighter-rouge">kubectl</code> 是k8s的管理工具，我们创建一个软链接，方便后续使用，如下</p><div class="language-shell highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="nb">ln</span> <span class="nt">-s</span> /opt/kubernetes/server/bin/kubectl /usr/local/bin/kubectl
</pre></table></code></div></div><h3 id="82-安装controller-manager"><span class="mr-2">8.2 安装controller-manager</span><a href="#82-安装controller-manager" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><h4 id="821-创建配置"><span class="mr-2">8.2.1 创建配置</span><a href="#821-创建配置" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>controller-manager 和 apiserver 之间的认证是通过 kubeconfig 的方式来认证的，即 controller-manager 的私钥、公钥及CA的证书要放在一个 kubeconfig 文件里。下面创建controller-manager所用的kubeconfig文件kube-controller-manager.kubeconfig，现在在<code class="language-plaintext highlighter-rouge">/etc/kubernetes/pki</code>里创建，然后移动到<code class="language-plaintext highlighter-rouge">/etc/kubernetes</code>里。</p><div class="language-bash highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre><span class="c"># 进入证书目录</span>
<span class="nb">cd</span> /etc/kubernetes/pki/
<span class="c"># 设置集群信息</span>
kubectl config set-cluster kubernetes <span class="nt">--certificate-authority</span><span class="o">=</span>ca.pem <span class="nt">--embed-certs</span><span class="o">=</span><span class="nb">true</span> <span class="nt">--server</span><span class="o">=</span>https://192.168.122.100:7443 <span class="nt">--kubeconfig</span><span class="o">=</span>kube-controller-manager.kubeconfig
<span class="c"># 设置用户信息，这里用户名是system:kube-controller-manager ，也就是前面controller-manager-csr.json里CN指定的。</span>
kubectl config set-credentials system:kube-controller-manager <span class="nt">--client-certificate</span><span class="o">=</span>controller-manager.pem <span class="nt">--client-key</span><span class="o">=</span>controller-manager-key.pem <span class="nt">--embed-certs</span><span class="o">=</span><span class="nb">true</span> <span class="nt">--kubeconfig</span><span class="o">=</span>kube-controller-manager.kubeconfig
<span class="c"># 设置上下文信息</span>
kubectl config set-context system:kube-controller-manager <span class="nt">--cluster</span><span class="o">=</span>kubernetes <span class="nt">--user</span><span class="o">=</span>system:kube-controller-manager <span class="nt">--kubeconfig</span><span class="o">=</span>kube-controller-manager.kubeconfig
<span class="c"># 设置默认的上下文</span>
kubectl config use-context system:kube-controller-manager <span class="nt">--kubeconfig</span><span class="o">=</span>kube-controller-manager.kubeconfig
<span class="c"># 将生成的证书移到/etc/kubernetes/</span>
<span class="nb">mv </span>kube-controller-manager.kubeconfig /etc/kubernetes/
</pre></table></code></div></div><p><code class="language-plaintext highlighter-rouge">/etc/kubernetes/kube-controller-manager.kubeconfig</code>配置文件只需生成一次，再传到其他主机即可。</p><h4 id="822-创建启动脚本"><span class="mr-2">8.2.2 创建启动脚本</span><a href="#822-创建启动脚本" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>创建文件<code class="language-plaintext highlighter-rouge">/opt/kubernetes/server/bin/kube-controller-manager.sh</code>，添加以下内容</p><div class="language-shell highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre><td class="rouge-code"><pre><span class="c">#!/bin/bash</span>
./kube-controller-manager <span class="se">\</span>
    <span class="nt">--v</span><span class="o">=</span>2 <span class="se">\</span>
    <span class="nt">--logtostderr</span><span class="o">=</span><span class="nb">true</span> <span class="se">\</span>
    <span class="nt">--bind-address</span><span class="o">=</span>127.0.0.1 <span class="se">\</span>
    <span class="nt">--root-ca-file</span><span class="o">=</span>/etc/kubernetes/pki/ca.pem <span class="se">\</span>
    <span class="nt">--cluster-signing-cert-file</span><span class="o">=</span>/etc/kubernetes/pki/ca.pem <span class="se">\</span>
    <span class="nt">--cluster-signing-key-file</span><span class="o">=</span>/etc/kubernetes/pki/ca-key.pem <span class="se">\</span>
    <span class="nt">--service-account-private-key-file</span><span class="o">=</span>/etc/kubernetes/pki/ca-key.pem <span class="se">\</span>
    <span class="nt">--kubeconfig</span><span class="o">=</span>/etc/kubernetes/kube-controller-manager.kubeconfig <span class="se">\</span>
    <span class="nt">--leader-elect</span><span class="o">=</span><span class="nb">true</span> <span class="se">\</span>
    <span class="nt">--use-service-account-credentials</span><span class="o">=</span><span class="nb">true</span> <span class="se">\</span>
    <span class="nt">--node-monitor-grace-period</span><span class="o">=</span>40s <span class="se">\</span>
    <span class="nt">--node-monitor-period</span><span class="o">=</span>5s <span class="se">\</span>
    <span class="nt">--controllers</span><span class="o">=</span><span class="k">*</span>,bootstrapsigner,tokencleaner <span class="se">\</span>
    <span class="nt">--allocate-node-cidrs</span><span class="o">=</span><span class="nb">true</span> <span class="se">\</span>
    <span class="nt">--cluster-cidr</span><span class="o">=</span>10.244.0.0/16 <span class="se">\</span>
    <span class="nt">--node-cidr-mask-size</span><span class="o">=</span>24
</pre></table></code></div></div><p>添加执行权限与创建日志目录</p><div class="language-shell highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="c"># 添加可执行权限</span>
<span class="nb">chmod</span> +x /opt/kubernetes/server/bin/kube-controller-manager.sh
</pre></table></code></div></div><p>创建supervisor脚本启动管理文件<code class="language-plaintext highlighter-rouge">/etc/supervisor/conf.d/kube-controller-manager.conf</code>，添加以下内容</p><div class="language-ini highlighter-rouge"><div class="code-header"> <span data-label-text="Ini"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre><td class="rouge-code"><pre><span class="nn">[program:kube-controller-manager-101]</span><span class="w">
</span><span class="py">directory</span><span class="p">=</span><span class="s">/opt/kubernetes/server/bin</span>
<span class="py">command</span><span class="p">=</span><span class="s">/opt/kubernetes/server/bin/kube-controller-manager.sh</span>
<span class="py">numprocs</span><span class="p">=</span><span class="s">1</span>
<span class="py">autostart</span><span class="p">=</span><span class="s">true</span>
<span class="py">autorestart</span><span class="p">=</span><span class="s">true</span>
<span class="py">startsecs</span><span class="p">=</span><span class="s">30</span>
<span class="py">startretries</span><span class="p">=</span><span class="s">3</span>
<span class="py">exitcodes</span><span class="p">=</span><span class="s">0,2</span>
<span class="py">stopsignal</span><span class="p">=</span><span class="s">QUIT</span>
<span class="py">stopwaitsecs</span><span class="p">=</span><span class="s">10</span>
<span class="py">user</span><span class="p">=</span><span class="s">root</span>
<span class="py">redirect_stderr</span><span class="p">=</span><span class="s">true</span>
<span class="py">stdout_logfile</span><span class="p">=</span><span class="s">/data/logs/supervisor/controller.stdout.log</span>
<span class="py">stdout_logfile_maxbytes</span><span class="p">=</span><span class="s">64MB</span>
<span class="py">stdout_logfile_backups</span><span class="p">=</span><span class="s">4</span>
<span class="py">stdout_capture_maxbytes</span><span class="p">=</span><span class="s">1MB</span>
<span class="py">stdout_event_enabled</span><span class="p">=</span><span class="s">false</span>
</pre></table></code></div></div><p>更新supervisor</p><div class="language-shell highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>supervisorctl update
</pre></table></code></div></div><h2 id="安装scheduler"><span class="mr-2">安装scheduler</span><a href="#安装scheduler" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><h3 id="91-创建配置"><span class="mr-2">9.1 创建配置</span><a href="#91-创建配置" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>scheduler 和 apiserver 之间的认证也是通过 kubeconfig 的方式来认证的，下面创建 scheduler 所用的 kubeconfig 文件 kube-scheduler.kubeconfig，现在在/etc/kubernetes/pki里创建，然后剪切到/etc/kubernetes里。</p><div class="language-bash highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre><span class="c"># 进入证书目录</span>
<span class="nb">cd</span> /etc/kubernetes/pki/
<span class="c"># 设置集群信息</span>
kubectl config set-cluster kubernetes <span class="nt">--certificate-authority</span><span class="o">=</span>ca.pem <span class="nt">--embed-certs</span><span class="o">=</span><span class="nb">true</span> <span class="nt">--server</span><span class="o">=</span>https://192.168.122.100:7443 <span class="nt">--kubeconfig</span><span class="o">=</span>kube-scheduler.kubeconfig
<span class="c"># 设置用户信息</span>
kubectl config set-credentials system:kube-scheduler <span class="nt">--client-certificate</span><span class="o">=</span>scheduler.pem <span class="nt">--client-key</span><span class="o">=</span>scheduler-key.pem <span class="nt">--embed-certs</span><span class="o">=</span><span class="nb">true</span> <span class="nt">--kubeconfig</span><span class="o">=</span>kube-scheduler.kubeconfig
<span class="c"># 设置上下文信息</span>
kubectl config set-context system:kube-scheduler <span class="nt">--cluster</span><span class="o">=</span>kubernetes <span class="nt">--user</span><span class="o">=</span>system:kube-scheduler <span class="nt">--kubeconfig</span><span class="o">=</span>kube-scheduler.kubeconfig
<span class="c"># 设置默认的上下文</span>
kubectl config use-context system:kube-scheduler <span class="nt">--kubeconfig</span><span class="o">=</span>kube-scheduler.kubeconfig
<span class="c"># 剪切到/etc/kubernetes</span>
<span class="nb">mv </span>kube-scheduler.kubeconfig /etc/kubernetes/
</pre></table></code></div></div><p><code class="language-plaintext highlighter-rouge">/etc/kubernetes/kube-scheduler.kubeconfig</code>配置文件也只需生成一次，再传到其他主机即可。</p><h3 id="92-创建启动脚本"><span class="mr-2">9.2 创建启动脚本</span><a href="#92-创建启动脚本" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>创建scheluder启动脚本文件<code class="language-plaintext highlighter-rouge">/opt/kubernetes/server/bin/kube-scheduler.sh</code>文件，添加以下内容</p><div class="language-shell highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="c">#!/bin/bash</span>
./kube-scheduler <span class="se">\</span>
    <span class="nt">--v</span><span class="o">=</span>2 <span class="se">\</span>
    <span class="nt">--bind-address</span><span class="o">=</span>127.0.0.1 <span class="se">\</span>
    <span class="nt">--leader-elect</span><span class="o">=</span><span class="nb">true</span> <span class="se">\</span>
    <span class="nt">--kubeconfig</span><span class="o">=</span>/etc/kubernetes/kube-scheduler.kubeconfig
</pre></table></code></div></div><p>添加脚本执行权限与创建日志目录</p><div class="language-shell highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="c"># 添加脚本的可执行权限</span>
<span class="nb">chmod</span> +x /opt/kubernetes/server/bin/kube-scheduler.sh
</pre></table></code></div></div><p>创建进程管理配置文件<code class="language-plaintext highlighter-rouge">/etc/supervisor/conf.d/kube-scheduler.conf</code>文件，添加以下内容</p><div class="language-ini highlighter-rouge"><div class="code-header"> <span data-label-text="Ini"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre><td class="rouge-code"><pre><span class="nn">[program:kube-scheduler-101]</span><span class="w">
</span><span class="py">directory</span><span class="p">=</span><span class="s">/opt/kubernetes/server/bin</span>
<span class="py">command</span><span class="p">=</span><span class="s">/opt/kubernetes/server/bin/kube-scheduler.sh</span>
<span class="py">numprocs</span><span class="p">=</span><span class="s">1</span>
<span class="py">autostart</span><span class="p">=</span><span class="s">true</span>
<span class="py">autorestart</span><span class="p">=</span><span class="s">true</span>
<span class="py">startsecs</span><span class="p">=</span><span class="s">30</span>
<span class="py">startretries</span><span class="p">=</span><span class="s">3</span>
<span class="py">exitcodes</span><span class="p">=</span><span class="s">0,2</span>
<span class="py">stopsignal</span><span class="p">=</span><span class="s">QUIT</span>
<span class="py">stopwaitsecs</span><span class="p">=</span><span class="s">10</span>
<span class="py">user</span><span class="p">=</span><span class="s">root</span>
<span class="py">redirect_stderr</span><span class="p">=</span><span class="s">true</span>
<span class="py">stdout_logfile</span><span class="p">=</span><span class="s">/data/logs/supervisor/scheduler.stdout.log</span>
<span class="py">stdout_logfile_maxbytes</span><span class="p">=</span><span class="s">64MB</span>
<span class="py">stdout_logfile_backups</span><span class="p">=</span><span class="s">4</span>
<span class="py">stdout_capture_maxbytes</span><span class="p">=</span><span class="s">1MB</span>
<span class="py">stdout_event_enabled</span><span class="p">=</span><span class="s">false</span>
</pre></table></code></div></div><p>更新supervisor</p><div class="language-shell highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>supervisorctl update
</pre></table></code></div></div><h2 id="集群验证"><span class="mr-2">集群验证</span><a href="#集群验证" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><h3 id="101-创建管理员配置"><span class="mr-2">10.1 创建管理员配置</span><a href="#101-创建管理员配置" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>创建管理员用户用的kubeconfig，最后拷贝为 <code class="language-plaintext highlighter-rouge">~/.kube/config</code> 作为默认的kubeconfig文件。</p><div class="language-bash highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre><span class="c"># 进入证书目录</span>
<span class="nb">cd</span> /etc/kubernetes/pki/
<span class="c"># 设置一个集群信息</span>
kubectl config set-cluster kubernetes <span class="nt">--certificate-authority</span><span class="o">=</span>ca.pem <span class="nt">--embed-certs</span><span class="o">=</span><span class="nb">true</span> <span class="nt">--server</span><span class="o">=</span>https://192.168.122.100:7443 <span class="nt">--kubeconfig</span><span class="o">=</span>admin.conf
<span class="c"># 设置用户信息</span>
kubectl config set-credentials admin <span class="nt">--client-certificate</span><span class="o">=</span>admin.pem <span class="nt">--client-key</span><span class="o">=</span>admin-key.pem <span class="nt">--embed-certs</span><span class="o">=</span><span class="nb">true</span> <span class="nt">--kubeconfig</span><span class="o">=</span>admin.conf
<span class="c"># 设置上下文</span>
kubectl config set-context kubernetes <span class="nt">--cluster</span><span class="o">=</span>kubernetes <span class="nt">--user</span><span class="o">=</span>admin <span class="nt">--kubeconfig</span><span class="o">=</span>admin.conf
<span class="c"># 设置默认上下文境</span>
kubectl config use-context kubernetes <span class="nt">--kubeconfig</span><span class="o">=</span>admin.conf
<span class="c"># 移动</span>
<span class="nb">mv </span>admin.conf /etc/kubernetes/
</pre></table></code></div></div><p>创建好之后同步到其他节点，再拷贝配置文件到用户目录。</p><h3 id="102-使用管理员配置"><span class="mr-2">10.2 使用管理员配置</span><a href="#102-使用管理员配置" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><div class="language-bash highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="nb">mkdir</span> <span class="nt">-p</span> ~/.kube
<span class="nb">cp</span> /etc/kubernetes/admin.conf ~/.kube/config
</pre></table></code></div></div><p>使用<code class="language-plaintext highlighter-rouge">kubectl get cs</code>检查集群状态，这时候你会发现类似如下的错误</p><div class="language-bash highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>Error from server <span class="o">(</span>Forbidden<span class="o">)</span>: Forbidden <span class="o">(</span><span class="nv">user</span><span class="o">=</span>admin, <span class="nv">verb</span><span class="o">=</span>get, <span class="nv">resource</span><span class="o">=</span>nodes, <span class="nv">subresource</span><span class="o">=</span>proxy<span class="o">)</span>
</pre></table></code></div></div><p>这代表我们创建的<code class="language-plaintext highlighter-rouge">admin</code>用户没有集群管理权限，绑定一个<code class="language-plaintext highlighter-rouge">cluster-admin</code>角色即可，如下命令</p><div class="language-bash highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>kubectl create clusterrolebinding system:anonymous <span class="nt">--clusterrole</span><span class="o">=</span>cluster-admin <span class="nt">--user</span><span class="o">=</span>admin
</pre></table></code></div></div><p>最后再使用<code class="language-plaintext highlighter-rouge">kubectl get cs</code>查看集群，如返回以下类似内容，则代表集群控制节点的服务正常</p><div class="language-shell highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre>root@k8s-101:~# kubectl get cs
Warning: v1 ComponentStatus is deprecated <span class="k">in </span>v1.19+
NAME                 STATUS    MESSAGE   ERROR
scheduler            Healthy   ok
controller-manager   Healthy   ok
etcd-0               Healthy   ok
</pre></table></code></div></div><p>不过这个命令将来可能会被废弃，目前也可以使用 <code class="language-plaintext highlighter-rouge">kubectl cluster-info</code> 命令查看 Kubernetes 集群的基本信息。</p><h2 id="安装kubelet"><span class="mr-2">安装kubelet</span><a href="#安装kubelet" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><h3 id="111-创建授权配置文件"><span class="mr-2">11.1 创建授权配置文件</span><a href="#111-创建授权配置文件" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>为用户 <code class="language-plaintext highlighter-rouge">kubelet-bootstrap</code> 授权，允许 <code class="language-plaintext highlighter-rouge">kubelet tls bootstrap</code> 创建 <code class="language-plaintext highlighter-rouge">CSR</code> 请求，执行如下命令</p><div class="language-bash highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>kubectl create clusterrolebinding kubelet-bootstrap1 <span class="nt">--clusterrole</span><span class="o">=</span>system:node-bootstrapper <span class="nt">--user</span><span class="o">=</span>kubelet-bootstrap
</pre></table></code></div></div><p>把 <code class="language-plaintext highlighter-rouge">system:certificates.k8s.io:certificatesigningrequests:nodeclient</code> 授权给 <code class="language-plaintext highlighter-rouge">kubelet-bootstrap</code>，目的是实现对 <code class="language-plaintext highlighter-rouge">CSR</code> 的自动审批，如下命令</p><div class="language-bash highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>kubectl create clusterrolebinding kubelet-bootstrap2 <span class="nt">--clusterrole</span><span class="o">=</span>system:certificates.k8s.io:certificatesigningrequests:nodeclient <span class="nt">--user</span><span class="o">=</span>kubelet-bootstrap
</pre></table></code></div></div><p>这个用户名是在配置 <code class="language-plaintext highlighter-rouge">apiserver</code> 时用到的token文件<code class="language-plaintext highlighter-rouge">/etc/kubernetes/bb.csv</code>里指定的。最后使用以下命令创建对应授权配置文件</p><div class="language-bash highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre><span class="c"># 进入证书目录</span>
<span class="nb">cd</span> /etc/kubernetes/pki/
<span class="c"># 创建集群信息</span>
kubectl config set-cluster kubernetes <span class="nt">--certificate-authority</span><span class="o">=</span>ca.pem <span class="nt">--embed-certs</span><span class="o">=</span><span class="nb">true</span> <span class="nt">--server</span><span class="o">=</span>https://192.168.122.100:7443 <span class="nt">--kubeconfig</span><span class="o">=</span>kubelet-bootstrap.conf
<span class="c"># 创建用户信息，注意token是上面创建的`bb.csv`里指定的token</span>
kubectl config set-credentials kubelet-bootstrap <span class="nt">--token</span><span class="o">=</span>e83b6b5f1d1dba4cf38a  <span class="nt">--kubeconfig</span><span class="o">=</span>kubelet-bootstrap.conf
<span class="c"># 设置上下文</span>
kubectl config set-context kubernetes <span class="nt">--cluster</span><span class="o">=</span>kubernetes <span class="nt">--user</span><span class="o">=</span>kubelet-bootstrap <span class="nt">--kubeconfig</span><span class="o">=</span>kubelet-bootstrap.conf
<span class="c"># 启用上下文</span>
kubectl config use-context kubernetes <span class="nt">--kubeconfig</span><span class="o">=</span>kubelet-bootstrap.conf
<span class="c"># 剪切配置文件到/etc/kubernetes</span>
<span class="nb">mv </span>kubelet-bootstrap.conf  /etc/kubernetes/
</pre></table></code></div></div><p>生成配置文件<code class="language-plaintext highlighter-rouge">/etc/kubernetes/kubelet-bootstrap.conf</code>之后，传到工作节点中，在这里是<code class="language-plaintext highlighter-rouge">k8s-102</code>和<code class="language-plaintext highlighter-rouge">k8s-103</code>。</p><h3 id="112-创建kubelet配置文件"><span class="mr-2">11.2 创建kubelet配置文件</span><a href="#112-创建kubelet配置文件" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>创建 kubelet 用到的配置文件 <code class="language-plaintext highlighter-rouge">/etc/kubernetes/kubelet-config.yaml</code>，后续 kubelet 配置启动文件需要用到，内容如下</p><div class="language-yaml highlighter-rouge"><div class="code-header"> <span data-label-text="YAML"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
</pre><td class="rouge-code"><pre><span class="na">apiVersion</span><span class="pi">:</span> <span class="s">kubelet.config.k8s.io/v1beta1</span>
<span class="na">address</span><span class="pi">:</span> <span class="s">0.0.0.0</span>
<span class="na">port</span><span class="pi">:</span> <span class="m">10250</span>
<span class="na">readOnlyPort</span><span class="pi">:</span> <span class="m">10255</span>
<span class="na">authentication</span><span class="pi">:</span>
  <span class="na">anonymous</span><span class="pi">:</span>
    <span class="na">enabled</span><span class="pi">:</span> <span class="kc">false</span>
  <span class="na">webhook</span><span class="pi">:</span>
    <span class="na">cacheTTL</span><span class="pi">:</span> <span class="s">0s</span>
    <span class="na">enabled</span><span class="pi">:</span> <span class="kc">true</span>
  <span class="na">x509</span><span class="pi">:</span>
    <span class="na">clientCAFile</span><span class="pi">:</span> <span class="s">/etc/kubernetes/pki/ca.pem</span>
<span class="na">authorization</span><span class="pi">:</span>
  <span class="na">mode</span><span class="pi">:</span> <span class="s">Webhook</span>
  <span class="na">webhook</span><span class="pi">:</span>
    <span class="na">cacheAuthorizedTTL</span><span class="pi">:</span> <span class="s">0s</span>
    <span class="na">cacheUnauthorizedTTL</span><span class="pi">:</span> <span class="s">0s</span>
<span class="na">cgroupDriver</span><span class="pi">:</span> <span class="s">systemd</span>
<span class="na">clusterDNS</span><span class="pi">:</span>
<span class="pi">-</span> <span class="s">10.96.0.10</span>
<span class="na">clusterDomain</span><span class="pi">:</span> <span class="s">cluster.local</span>
<span class="na">cpuManagerReconcilePeriod</span><span class="pi">:</span> <span class="s">0s</span>
<span class="na">evictionPressureTransitionPeriod</span><span class="pi">:</span> <span class="s">0s</span>
<span class="na">fileCheckFrequency</span><span class="pi">:</span> <span class="s">0s</span>
<span class="na">healthzBindAddress</span><span class="pi">:</span> <span class="s">127.0.0.1</span>
<span class="na">httpCheckFrequency</span><span class="pi">:</span> <span class="s">0s</span>
<span class="na">imageMinimumGCAge</span><span class="pi">:</span> <span class="s">0s</span>
<span class="na">kind</span><span class="pi">:</span> <span class="s">KubeletConfiguration</span>
<span class="na">podInfraContainerImage</span><span class="pi">:</span> <span class="s2">"</span><span class="s">registry.aliyuncs.com/google_containers/pause:3.10"</span>
</pre></table></code></div></div><p>这里我们指定clusterDNS的IP是<code class="language-plaintext highlighter-rouge">10.96.0.10</code>，后续我们会在<code class="language-plaintext highlighter-rouge">kube-dns</code>中配置<code class="language-plaintext highlighter-rouge">CoreDNS</code>的IP为<code class="language-plaintext highlighter-rouge">10.96.0.10</code>。</p><h3 id="113-配置kubelet启动脚本"><span class="mr-2">11.3 配置kubelet启动脚本</span><a href="#113-配置kubelet启动脚本" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><h4 id="1131-配置启动脚本"><span class="mr-2">11.3.1 配置启动脚本</span><a href="#1131-配置启动脚本" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>接下来在<code class="language-plaintext highlighter-rouge">k8s-102</code>和<code class="language-plaintext highlighter-rouge">k8s-103</code>上启动kubelet，在让kubelet启动之前，我们需要有一个基础的pause镜像，以下是拉取命令，该镜像负责其k8s集群中pod启动之前的初始化操作</p><div class="language-bash highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>nerdctl pull registry.aliyuncs.com/google_containers/pause:3.10
</pre></table></code></div></div><p>创建kubelet的启动脚本文件<code class="language-plaintext highlighter-rouge">/opt/kubernetes/server/bin/kubelet.sh</code>文件，添加以下内容</p><div class="language-bash highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="c">#!/bin/bash</span>
./kubelet <span class="se">\</span>
    <span class="nt">--bootstrap-kubeconfig</span><span class="o">=</span>/etc/kubernetes/kubelet-bootstrap.conf  <span class="se">\</span>
    <span class="nt">--cert-dir</span><span class="o">=</span>/var/lib/kubelet/pki <span class="se">\</span>
    <span class="nt">--hostname-override</span><span class="o">=</span>k8s-102 <span class="se">\</span>
    <span class="nt">--kubeconfig</span><span class="o">=</span>/etc/kubernetes/kubelet.kubeconfig <span class="se">\</span>
    <span class="nt">--config</span><span class="o">=</span>/etc/kubernetes/kubelet-config.yaml <span class="se">\</span>
    <span class="nt">--v</span><span class="o">=</span>2
</pre></table></code></div></div><p>添加可执行权限</p><div class="language-bash highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="nb">chmod</span> +x /opt/kubernetes/server/bin/kubelet.sh
</pre></table></code></div></div><p>创建数据目录和日志目录</p><div class="language-bash highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="c"># 创建kubelet所需要的日志目录</span>
<span class="nb">mkdir</span> <span class="nt">-p</span> /var/log/kubernetes
</pre></table></code></div></div><h4 id="1132-配置管理服务"><span class="mr-2">11.3.2 配置管理服务</span><a href="#1132-配置管理服务" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>创建supervisor进程配置文件<code class="language-plaintext highlighter-rouge">/etc/supervisor/conf.d/kube-kubelet.conf</code>文件，添加以下内容</p><div class="language-ini highlighter-rouge"><div class="code-header"> <span data-label-text="Ini"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre><td class="rouge-code"><pre><span class="nn">[program:kube-kubelet-102]</span><span class="w">
</span><span class="py">directory</span><span class="p">=</span><span class="s">/opt/kubernetes/server/bin</span>
<span class="py">command</span><span class="p">=</span><span class="s">/opt/kubernetes/server/bin/kubelet.sh</span>
<span class="py">numprocs</span><span class="p">=</span><span class="s">1</span>
<span class="py">autostart</span><span class="p">=</span><span class="s">true</span>
<span class="py">autorestart</span><span class="p">=</span><span class="s">true</span>
<span class="py">startsecs</span><span class="p">=</span><span class="s">30</span>
<span class="py">startretries</span><span class="p">=</span><span class="s">3</span>
<span class="py">exitcodes</span><span class="p">=</span><span class="s">0,2</span>
<span class="py">stopsignal</span><span class="p">=</span><span class="s">QUIT</span>
<span class="py">stopwaitsecs</span><span class="p">=</span><span class="s">10</span>
<span class="py">user</span><span class="p">=</span><span class="s">root</span>
<span class="py">redirect_stderr</span><span class="p">=</span><span class="s">true</span>
<span class="py">stdout_logfile</span><span class="p">=</span><span class="s">/data/logs/supervisor/kubelet.stdout.log</span>
<span class="py">stdout_logfile_maxbytes</span><span class="p">=</span><span class="s">64MB</span>
<span class="py">stdout_logfile_backups</span><span class="p">=</span><span class="s">4</span>
<span class="py">stdout_capture_maxbytes</span><span class="p">=</span><span class="s">1MB</span>
<span class="py">stdout_event_enabled</span><span class="p">=</span><span class="s">false</span>
</pre></table></code></div></div><p>更新supervisord，如下命令</p><div class="language-shell highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>supervisorctl update
</pre></table></code></div></div><h4 id="1133-验证集群"><span class="mr-2">11.3.3 验证集群</span><a href="#1133-验证集群" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>此时，服务已经正常运行了，可以使用以下<code class="language-plaintext highlighter-rouge">kubectl</code>命令在查看节点信息</p><div class="language-shell highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>kubectl get nodes
</pre></table></code></div></div><p>如果看到以下信息，代表安装成功</p><div class="language-bash highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre>NAME       STATUS   ROLES    AGE   VERSION
k8s-102   Ready    &lt;none&gt;   19m   v1.32.2
k8s-103   Ready    &lt;none&gt;   18m   v1.32.2
</pre></table></code></div></div><p>我们还可以设置集群的标签</p><div class="language-bash highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="c"># 设置集群为node标签</span>
kubectl label node k8s-102 node-role.kubernetes.io/node<span class="o">=</span>
kubectl label node k8s-103 node-role.kubernetes.io/node<span class="o">=</span>
</pre></table></code></div></div><h2 id="安装proxy"><span class="mr-2">安装proxy</span><a href="#安装proxy" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><h3 id="121-创建kubeconfig配置文件"><span class="mr-2">12.1 创建kubeconfig配置文件</span><a href="#121-创建kubeconfig配置文件" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>在<code class="language-plaintext highlighter-rouge">k8s-101</code>服务器上执行，如下命令</p><div class="language-bash highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre><span class="c"># 进入证书目录</span>
<span class="nb">cd</span> /etc/kubernetes/pki/
<span class="c"># 创建集群信息</span>
kubectl config set-cluster kubernetes <span class="nt">--certificate-authority</span><span class="o">=</span>ca.pem <span class="nt">--embed-certs</span><span class="o">=</span><span class="nb">true</span> <span class="nt">--server</span><span class="o">=</span>https://192.168.122.100:7443 <span class="nt">--kubeconfig</span><span class="o">=</span>kube-proxy.kubeconfig
<span class="c"># 创建用户信息</span>
kubectl config set-credentials kube-proxy <span class="nt">--client-certificate</span><span class="o">=</span>proxy.pem <span class="nt">--client-key</span><span class="o">=</span>proxy-key.pem <span class="nt">--embed-certs</span><span class="o">=</span><span class="nb">true</span> <span class="nt">--kubeconfig</span><span class="o">=</span>kube-proxy.kubeconfig
<span class="c"># 创建上下文</span>
kubectl config set-context default <span class="nt">--cluster</span><span class="o">=</span>kubernetes <span class="nt">--user</span><span class="o">=</span>kube-proxy <span class="nt">--kubeconfig</span><span class="o">=</span>kube-proxy.kubeconfig
<span class="c"># 应用上下文</span>
kubectl config use-context default <span class="nt">--kubeconfig</span><span class="o">=</span>kube-proxy.kubeconfig
<span class="c"># 移动到/etc/kubernetes/</span>
<span class="nb">mv </span>kube-proxy.kubeconfig /etc/kubernetes/
</pre></table></code></div></div><p>创建完成后，同步到工作节点<code class="language-plaintext highlighter-rouge">192-debian</code>和<code class="language-plaintext highlighter-rouge">160-debian</code>。</p><h3 id="122-创建kube-proxy配置文件"><span class="mr-2">12.2 创建kube-proxy配置文件</span><a href="#122-创建kube-proxy配置文件" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>在工作节点创建<code class="language-plaintext highlighter-rouge">/etc/kubernetes/kube-proxy.yaml</code>，内容如下</p><div class="language-bash highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre>apiVersion: kubeproxy.config.k8s.io/v1alpha1
bindAddress: 0.0.0.0
clientConnection:
  kubeconfig: /etc/kubernetes/kube-proxy.kubeconfig
clusterCIDR: 10.244.0.0/16
kind: KubeProxyConfiguration
metricsBindAddress: 0.0.0.0:10249
mode: <span class="s2">"ipvs"</span>
</pre></table></code></div></div><h3 id="123-创建启动脚本"><span class="mr-2">12.3 创建启动脚本</span><a href="#123-创建启动脚本" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>在两台主机执行以上脚本之后，我们创建<code class="language-plaintext highlighter-rouge">kube-proxy</code>的启动脚本文件<code class="language-plaintext highlighter-rouge">/opt/kubernetes/server/bin/kube-proxy.sh</code></p><div class="language-shell highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="c">#!/bin/bash</span>
./kube-proxy <span class="se">\</span>
  <span class="nt">--config</span><span class="o">=</span>/etc/kubernetes/kube-proxy.yaml <span class="se">\</span>
  <span class="nt">--v</span><span class="o">=</span>2
</pre></table></code></div></div><p>添加可执行权限</p><div class="language-shell highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="nb">chmod</span> +x /opt/kubernetes/server/bin/kube-proxy.sh
</pre></table></code></div></div><h3 id="134-创建服务配置"><span class="mr-2">13.4 创建服务配置</span><a href="#134-创建服务配置" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>创建supervisor的配置文件<code class="language-plaintext highlighter-rouge">/etc/supervisor/conf.d/kube-proxy.conf</code>文件，添加以下内容</p><div class="language-ini highlighter-rouge"><div class="code-header"> <span data-label-text="Ini"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre><td class="rouge-code"><pre><span class="nn">[program:kube-proxy-102]</span><span class="w">
</span><span class="py">directory</span><span class="p">=</span><span class="s">/opt/kubernetes/server/bin</span>
<span class="py">command</span><span class="p">=</span><span class="s">/opt/kubernetes/server/bin/kube-proxy.sh</span>
<span class="py">numprocs</span><span class="p">=</span><span class="s">1</span>
<span class="py">autostart</span><span class="p">=</span><span class="s">true</span>
<span class="py">autorestart</span><span class="p">=</span><span class="s">true</span>
<span class="py">startsecs</span><span class="p">=</span><span class="s">30</span>
<span class="py">startretries</span><span class="p">=</span><span class="s">3</span>
<span class="py">exitcodes</span><span class="p">=</span><span class="s">0,2</span>
<span class="py">stopsignal</span><span class="p">=</span><span class="s">QUIT</span>
<span class="py">stopwaitsecs</span><span class="p">=</span><span class="s">10</span>
<span class="py">user</span><span class="p">=</span><span class="s">root</span>
<span class="py">redirect_stderr</span><span class="p">=</span><span class="s">true</span>
<span class="py">stdout_logfile</span><span class="p">=</span><span class="s">/data/logs/supervisor/kube-proxy.stdout.log</span>
<span class="py">stdout_logfile_maxbytes</span><span class="p">=</span><span class="s">64MB</span>
<span class="py">stdout_logfile_backups</span><span class="p">=</span><span class="s">4</span>
<span class="py">stdout_capture_maxbytes</span><span class="p">=</span><span class="s">1MB</span>
<span class="py">stdout_event_enabled</span><span class="p">=</span><span class="s">false</span>
</pre></table></code></div></div><p>更新supervisor</p><div class="language-shell highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>supervisorctl update
</pre></table></code></div></div><h3 id="125-创建权限配置文件"><span class="mr-2">12.5 创建权限配置文件</span><a href="#125-创建权限配置文件" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p><code class="language-plaintext highlighter-rouge">kube-proxy</code> 是 Kubernetes 集群中的一个核心组件，负责在每个节点上维护网络规则，确保 Pod 之间的网络通信。为了实现这一功能，<code class="language-plaintext highlighter-rouge">kube-proxy</code> 需要与 Kubernetes API Server 进行交互，获取集群的网络信息（如 Service、Endpoint 等），并根据这些信息配置本地的网络规则（如 iptables 或 ipvs）。为了与 API Server 交互，<code class="language-plaintext highlighter-rouge">kube-proxy</code> 需要一定的权限，特别是访问节点资源的权限。</p><p>RBAC（基于角色的访问控制）是 Kubernetes 中用于管理权限的机制。通过创建 RBAC 配置，<code class="language-plaintext highlighter-rouge">kube-proxy</code> 被授予了以下权限：访问 nodes/proxy、nodes/stats、nodes/log 等资源，以便获取节点的网络和状态信息。执行相关操作（如 get、list、watch 等）来维护网络规则。如果没有这些权限，<code class="language-plaintext highlighter-rouge">kube-proxy</code> 将无法正常工作，导致集群中的网络功能失效。因此，启动 <code class="language-plaintext highlighter-rouge">kube-proxy</code> 之后创建 RBAC 配置是必要的。</p><p>在<code class="language-plaintext highlighter-rouge">k8s-101</code>上创建<code class="language-plaintext highlighter-rouge">/etc/kubernetes/rbac.yaml</code>，写入如下内容</p><div class="language-yml highlighter-rouge"><div class="code-header"> <span data-label-text="YAML"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
</pre><td class="rouge-code"><pre><span class="na">apiVersion</span><span class="pi">:</span> <span class="s">rbac.authorization.k8s.io/v1</span>
<span class="na">kind</span><span class="pi">:</span> <span class="s">ClusterRole</span>
<span class="na">metadata</span><span class="pi">:</span>
  <span class="na">annotations</span><span class="pi">:</span>
    <span class="na">rbac.authorization.kubernetes.io/autoupdate</span><span class="pi">:</span> <span class="s2">"</span><span class="s">true"</span>
  <span class="na">labels</span><span class="pi">:</span>
    <span class="na">kubernetes.io/bootstrapping</span><span class="pi">:</span> <span class="s">rbac-defaults</span>
  <span class="na">name</span><span class="pi">:</span> <span class="s">system:kubernetes-to-kubelet</span>
<span class="na">rules</span><span class="pi">:</span>
  <span class="pi">-</span> <span class="na">apiGroups</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s2">"</span><span class="s">"</span>
    <span class="na">resources</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s">nodes/proxy</span>
      <span class="pi">-</span> <span class="s">nodes/stats</span>
      <span class="pi">-</span> <span class="s">nodes/log</span>
      <span class="pi">-</span> <span class="s">nodes/spec</span>
      <span class="pi">-</span> <span class="s">nodes/metrics</span>
    <span class="na">verbs</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s2">"</span><span class="s">*"</span>
<span class="nn">---</span>
<span class="na">apiVersion</span><span class="pi">:</span> <span class="s">rbac.authorization.k8s.io/v1</span>
<span class="na">kind</span><span class="pi">:</span> <span class="s">ClusterRoleBinding</span>
<span class="na">metadata</span><span class="pi">:</span>
  <span class="na">name</span><span class="pi">:</span> <span class="s">system:kubernetes</span>
  <span class="na">namespace</span><span class="pi">:</span> <span class="s2">"</span><span class="s">"</span>
<span class="na">roleRef</span><span class="pi">:</span>
  <span class="na">apiGroup</span><span class="pi">:</span> <span class="s">rbac.authorization.k8s.io</span>
  <span class="na">kind</span><span class="pi">:</span> <span class="s">ClusterRole</span>
  <span class="na">name</span><span class="pi">:</span> <span class="s">system:kubernetes-to-kubelet</span>
<span class="na">subjects</span><span class="pi">:</span>
  <span class="pi">-</span> <span class="na">apiGroup</span><span class="pi">:</span> <span class="s">rbac.authorization.k8s.io</span>
    <span class="na">kind</span><span class="pi">:</span> <span class="s">User</span>
    <span class="na">name</span><span class="pi">:</span> <span class="s">kubernetes</span>
</pre></table></code></div></div><h3 id="126-创建角色及授权"><span class="mr-2">12.6 创建角色及授权</span><a href="#126-创建角色及授权" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><div class="language-bash highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>kubectl apply <span class="nt">-f</span> /etc/kubernetes/rbac.yaml
</pre></table></code></div></div><h3 id="127-集群的验证"><span class="mr-2">12.7 集群的验证</span><a href="#127-集群的验证" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>在两个节点都启动好kube-proxy服务之后，至此，集群的基本组件已经安装完成，下面我们来验证集群。在任意管理节点创建一个Pod类型的资源，添加<code class="language-plaintext highlighter-rouge">nginx-pod.yml</code>文件，添加以下内容</p><div class="language-yaml highlighter-rouge"><div class="code-header"> <span data-label-text="YAML"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre><span class="na">apiVersion</span><span class="pi">:</span> <span class="s">v1</span>
<span class="na">kind</span><span class="pi">:</span> <span class="s">Pod</span>
<span class="na">metadata</span><span class="pi">:</span>
  <span class="na">name</span><span class="pi">:</span> <span class="s">pod1</span>
<span class="na">spec</span><span class="pi">:</span>
  <span class="na">containers</span><span class="pi">:</span>
  <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">nginx-pod</span>
    <span class="na">image</span><span class="pi">:</span> <span class="s">nginx:alpine</span>
    <span class="na">imagePullPolicy</span><span class="pi">:</span> <span class="s">IfNotPresent</span>
    <span class="na">ports</span><span class="pi">:</span>
    <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">nginxport</span>
      <span class="na">containerPort</span><span class="pi">:</span> <span class="m">80</span>
</pre></table></code></div></div><p>执行资源创建命令</p><div class="language-shell highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>kubectl create <span class="nt">-f</span> nginx-pod.yml
</pre></table></code></div></div><p>使用以下命令验证pod是否正常运行</p><div class="language-shell highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>kubectl get pod <span class="nt">-o</span> wide
</pre></table></code></div></div><p>如果返回如下内容，代表集群正常</p><div class="language-shell highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre>NAME   READY   STATUS    RESTARTS   AGE   IP          NODE       NOMINATED NODE   READINESS GATES
pod1   1/1     Running   0          94s   10.22.0.2   k8s-103   &lt;none&gt;           &lt;none&gt;
</pre></table></code></div></div><p>创建的pod运行在<code class="language-plaintext highlighter-rouge">k8s-103</code>这台主机上，在这台机使用<code class="language-plaintext highlighter-rouge">curl 10.22.0.2</code>命令能正常访问到nginx服务。但是如果我们在另一个节点<code class="language-plaintext highlighter-rouge">k8s-102</code>上执行<code class="language-plaintext highlighter-rouge">curl 10.22.0.2</code>会发现访问不到。原因是这两个节点上的容器在各自的虚拟网络内，我们将到后续的章节安装通过安装 k8s 网络插件的方式，实现不同工作节点的容器网络互相访问的功能。</p><h2 id="安装网络插件"><span class="mr-2">安装网络插件</span><a href="#安装网络插件" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>以下的操作，我们在<code class="language-plaintext highlighter-rouge">k8s-101</code>节点去完成。</p><h3 id="131-安装calico"><span class="mr-2">13.1 安装calico</span><a href="#131-安装calico" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>Calico 是 Kubernetes 集群的网络基础设施，负责 Pod 的网络连接、跨节点通信和网络策略管理。根据以下步骤进行安装。</p><div class="language-bash highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="nb">cd</span> /etc/kubernetes
wget https://docs.projectcalico.org/manifests/calico.yaml
</pre></table></code></div></div><p>修改calico.yaml文件，将<code class="language-plaintext highlighter-rouge">CALICO_IPV4POOL_CIDR</code>改为和<code class="language-plaintext highlighter-rouge">kube-proxy</code>的配置一样，如下</p><div class="language-ini highlighter-rouge"><div class="code-header"> <span data-label-text="Ini"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="na">-</span><span class="w"> </span><span class="na">name:</span><span class="w"> </span><span class="na">CALICO_IPV4POOL_CIDR</span><span class="w">
  </span><span class="na">value:</span><span class="w"> </span><span class="na">"10.244.0.0/16"</span><span class="w">
</span></pre></table></code></div></div><p>在calico配置文件中，定义了一下容器镜像，在运行calico的时候将会用到，可以使用 <code class="language-plaintext highlighter-rouge">cat calico.yaml | grep image</code> 命令查看所有需要的镜像列表，如下</p><div class="language-yaml highlighter-rouge"><div class="code-header"> <span data-label-text="YAML"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre><span class="na">image</span><span class="pi">:</span> <span class="s">docker.io/calico/cni:v3.25.0</span>
<span class="na">imagePullPolicy</span><span class="pi">:</span> <span class="s">IfNotPresent</span>
<span class="na">image</span><span class="pi">:</span> <span class="s">docker.io/calico/cni:v3.25.0</span>
<span class="na">imagePullPolicy</span><span class="pi">:</span> <span class="s">IfNotPresent</span>
<span class="na">image</span><span class="pi">:</span> <span class="s">docker.io/calico/node:v3.25.0</span>
<span class="na">imagePullPolicy</span><span class="pi">:</span> <span class="s">IfNotPresent</span>
<span class="na">image</span><span class="pi">:</span> <span class="s">docker.io/calico/node:v3.25.0</span>
<span class="na">imagePullPolicy</span><span class="pi">:</span> <span class="s">IfNotPresent</span>
<span class="na">image</span><span class="pi">:</span> <span class="s">docker.io/calico/kube-controllers:v3.25.0</span>
<span class="na">imagePullPolicy</span><span class="pi">:</span> <span class="s">IfNotPresent</span>
</pre></table></code></div></div><p>我们可以看到，这些镜像都来自<code class="language-plaintext highlighter-rouge">docker.io</code>，但因为一些原因，在撰写这篇文档时，国内访问 <code class="language-plaintext highlighter-rouge">docker.io</code> 的网络不太顺畅。因此你需要想办法让你的工作节点宿主机能拉取到这些镜像，最后再创建<code class="language-plaintext highlighter-rouge">calico</code>服务。或者你需要修改配置文件，改成这些镜像在可以拉取到的国内镜像站对应的镜像名。</p><p>解决依赖的镜像的拉取问题后，最后创建calico服务</p><div class="language-bash highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>kubectl apply <span class="nt">-fcalico</span>.yaml
</pre></table></code></div></div><p>执行命令之后，calico会拉去远端的镜像并运行，执行 <code class="language-plaintext highlighter-rouge">kubectl get pods -n kube-system</code> 等到所有pod都处于<code class="language-plaintext highlighter-rouge">Running</code>状态代表服务启动完成，如下</p><div class="language-bash highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre>NAME                                       READY   STATUS    RESTARTS   AGE
calico-kube-controllers-6799f5f4b4-xqpf9   1/1     Running   0          3m34s
calico-node-9bt29                          1/1     Running   0          3m34s
calico-node-djxvc                          1/1     Running   0          3m34s
</pre></table></code></div></div><p>此时calico已经正常运行了，如果上节创建的nginx的pod还没有删除的话，先删除掉再创建，如下命令</p><div class="language-bash highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre>kubectl delete <span class="nt">-f</span> nginx-pod.yaml
kubectl apply <span class="nt">-f</span> nginx-pod.yaml
</pre></table></code></div></div><p>创建新的pod之后，使用<code class="language-plaintext highlighter-rouge">kubectl get pod -o wide</code>查看pod所处的节点，此时我们在任意工作节点请求该IP，都能成功请求。</p><h3 id="132-安装coredns"><span class="mr-2">13.2 安装coredns</span><a href="#132-安装coredns" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>CoreDNS 是 Kubernetes 集群的 DNS 服务，负责为集群内的服务提供域名解析和服务发现功能，使得 Pod 可以通过服务名称访问其他服务。它允许 Pod 通过服务名称（如 <code class="language-plaintext highlighter-rouge">my-service.default.svc.cluster.local</code>）来访问其他服务，而不需要知道具体的 IP 地址。</p><h4 id="1321-下载基础资源配置文件"><span class="mr-2">13.2.1 下载基础资源配置文件</span><a href="#1321-下载基础资源配置文件" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>下载corndns资源配置文件</p><div class="language-bash highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="nb">cd</span> /etc/kubernetes
wget https://github.com/kubernetes/kubernetes/blob/master/cluster/addons/dns/coredns/coredns.yaml.base <span class="nt">-O</span> coredns.yml
</pre></table></code></div></div><h4 id="1322-修改配置"><span class="mr-2">13.2.2 修改配置</span><a href="#1322-修改配置" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>做出以下修改：</p><p>找到配置文件中的<code class="language-plaintext highlighter-rouge">__DNS__DOMAIN__</code>这两个变量改为集群域名，如下</p><div class="language-yml highlighter-rouge"><div class="code-header"> <span data-label-text="YAML"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="s">kubernetes cluster.local in-addr.arpa ip6.arpa {</span>
  <span class="s">fallthrough in-addr.arpa ip6.arpa</span>
<span class="err">}</span>
</pre></table></code></div></div><p>将 <code class="language-plaintext highlighter-rouge">__DNS__MEMORY__LIMIT_</code> 改为<code class="language-plaintext highlighter-rouge">512Mi</code>，如下</p><p>将<code class="language-plaintext highlighter-rouge">__DNS_SERVER__</code>改为kubelet配置文件中指定的集群IP地址<code class="language-plaintext highlighter-rouge">10.96.0.10</code>，如下</p><div class="language-yml highlighter-rouge"><div class="code-header"> <span data-label-text="YAML"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="na">spec</span><span class="pi">:</span>
  <span class="na">selector</span><span class="pi">:</span>
    <span class="na">k8s-app</span><span class="pi">:</span> <span class="s">kube-dns</span>
  <span class="na">clusterIP</span><span class="pi">:</span> <span class="s">10.96.0.10</span>
</pre></table></code></div></div><h4 id="1323-启动服务"><span class="mr-2">13.2.3 启动服务</span><a href="#1323-启动服务" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>使用以下命令启动服务</p><div class="language-bash highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>kubectl apply <span class="nt">-f</span> coredns.yml
</pre></table></code></div></div><h2 id="安装traefik-ingress"><span class="mr-2">安装traefik-ingress</span><a href="#安装traefik-ingress" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><h3 id="141-启动traefik服务"><span class="mr-2">14.1 启动traefik服务</span><a href="#141-启动traefik服务" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>Traefik 在 Kubernetes (k8s) 中的作用主要是作为反向代理和负载均衡器，负责管理外部流量到集群内部服务的路由。我们先定义 traefik 的资源，在<code class="language-plaintext highlighter-rouge">/etc/kubernetes</code>目录下创建<code class="language-plaintext highlighter-rouge">traefik.yml</code>文件，添加以下内容</p><div class="language-yaml highlighter-rouge"><div class="code-header"> <span data-label-text="YAML"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
</pre><td class="rouge-code"><pre><span class="na">apiVersion</span><span class="pi">:</span> <span class="s">v1</span>
<span class="na">kind</span><span class="pi">:</span> <span class="s">ServiceAccount</span>
<span class="na">metadata</span><span class="pi">:</span>
  <span class="na">name</span><span class="pi">:</span> <span class="s">traefik-ingress-controller</span>
  <span class="na">namespace</span><span class="pi">:</span> <span class="s">kube-system</span>
<span class="nn">---</span>
<span class="c1"># 定义角色</span>
<span class="na">apiVersion</span><span class="pi">:</span> <span class="s">rbac.authorization.k8s.io/v1</span>
<span class="na">kind</span><span class="pi">:</span> <span class="s">ClusterRole</span>
<span class="na">metadata</span><span class="pi">:</span>
  <span class="na">name</span><span class="pi">:</span> <span class="s">traefik-ingress-controller</span>
<span class="na">rules</span><span class="pi">:</span>
  <span class="pi">-</span> <span class="na">apiGroups</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s2">"</span><span class="s">"</span>
    <span class="na">resources</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s">services</span>
      <span class="pi">-</span> <span class="s">endpoints</span>
      <span class="pi">-</span> <span class="s">secrets</span>
    <span class="na">verbs</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s">get</span>
      <span class="pi">-</span> <span class="s">list</span>
      <span class="pi">-</span> <span class="s">watch</span>
  <span class="pi">-</span> <span class="na">apiGroups</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s">extensions</span>
      <span class="pi">-</span> <span class="s">networking.k8s.io</span>
    <span class="na">resources</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s">ingresses</span>
      <span class="pi">-</span> <span class="s">ingressclasses</span>
    <span class="na">verbs</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s">get</span>
      <span class="pi">-</span> <span class="s">list</span>
      <span class="pi">-</span> <span class="s">watch</span>
  <span class="pi">-</span> <span class="na">apiGroups</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s">extensions</span>
      <span class="pi">-</span> <span class="s">networking.k8s.io</span>
    <span class="na">resources</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s">ingresses/status</span>
    <span class="na">verbs</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s">update</span>
<span class="nn">---</span>
<span class="c1"># 创建角色和账号绑定</span>
<span class="na">apiVersion</span><span class="pi">:</span> <span class="s">rbac.authorization.k8s.io/v1</span>
<span class="na">kind</span><span class="pi">:</span> <span class="s">ClusterRoleBinding</span>
<span class="na">metadata</span><span class="pi">:</span>
  <span class="na">name</span><span class="pi">:</span> <span class="s">traefik-ingress-controller</span>
<span class="na">roleRef</span><span class="pi">:</span>
  <span class="na">apiGroup</span><span class="pi">:</span> <span class="s">rbac.authorization.k8s.io</span>
  <span class="na">kind</span><span class="pi">:</span> <span class="s">ClusterRole</span>
  <span class="na">name</span><span class="pi">:</span> <span class="s">traefik-ingress-controller</span>
<span class="na">subjects</span><span class="pi">:</span>
  <span class="pi">-</span> <span class="na">kind</span><span class="pi">:</span> <span class="s">ServiceAccount</span>
    <span class="na">name</span><span class="pi">:</span> <span class="s">traefik-ingress-controller</span>
    <span class="na">namespace</span><span class="pi">:</span> <span class="s">kube-system</span>
<span class="nn">---</span>
<span class="c1"># 创建traefik服务</span>
<span class="na">apiVersion</span><span class="pi">:</span> <span class="s">apps/v1</span>
<span class="na">kind</span><span class="pi">:</span> <span class="s">Deployment</span>
<span class="na">metadata</span><span class="pi">:</span>
  <span class="na">name</span><span class="pi">:</span> <span class="s">traefik</span>
  <span class="na">namespace</span><span class="pi">:</span> <span class="s">kube-system</span>
  <span class="na">labels</span><span class="pi">:</span>
    <span class="na">app</span><span class="pi">:</span> <span class="s">traefik</span>
<span class="na">spec</span><span class="pi">:</span>
  <span class="na">replicas</span><span class="pi">:</span> <span class="m">1</span>
  <span class="na">selector</span><span class="pi">:</span>
    <span class="na">matchLabels</span><span class="pi">:</span>
      <span class="na">app</span><span class="pi">:</span> <span class="s">traefik</span>
  <span class="na">template</span><span class="pi">:</span>
    <span class="na">metadata</span><span class="pi">:</span>
      <span class="na">labels</span><span class="pi">:</span>
        <span class="na">app</span><span class="pi">:</span> <span class="s">traefik</span>
    <span class="na">spec</span><span class="pi">:</span>
      <span class="na">serviceAccountName</span><span class="pi">:</span> <span class="s">traefik-ingress-controller</span>
      <span class="na">containers</span><span class="pi">:</span>
        <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">traefik</span>
          <span class="na">image</span><span class="pi">:</span> <span class="s">traefik:v2.10</span>
          <span class="na">ports</span><span class="pi">:</span>
            <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">web</span>
              <span class="na">containerPort</span><span class="pi">:</span> <span class="m">80</span>
            <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">websecure</span>
              <span class="na">containerPort</span><span class="pi">:</span> <span class="m">443</span>
            <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">admin</span>
              <span class="na">containerPort</span><span class="pi">:</span> <span class="m">8080</span>
          <span class="na">args</span><span class="pi">:</span>
            <span class="pi">-</span> <span class="s">--api.insecure=true</span>
            <span class="pi">-</span> <span class="s">--providers.kubernetesingress</span>
            <span class="pi">-</span> <span class="s">--entrypoints.web.Address=:80</span>
            <span class="pi">-</span> <span class="s">--entrypoints.websecure.Address=:443</span>
<span class="nn">---</span>
<span class="c1"># 创建traefik的service</span>
<span class="na">apiVersion</span><span class="pi">:</span> <span class="s">v1</span>
<span class="na">kind</span><span class="pi">:</span> <span class="s">Service</span>
<span class="na">metadata</span><span class="pi">:</span>
  <span class="na">name</span><span class="pi">:</span> <span class="s">traefik</span>
  <span class="na">namespace</span><span class="pi">:</span> <span class="s">kube-system</span>
<span class="na">spec</span><span class="pi">:</span>
  <span class="na">type</span><span class="pi">:</span> <span class="s">NodePort</span>
  <span class="na">ports</span><span class="pi">:</span>
    <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">http</span>
      <span class="na">port</span><span class="pi">:</span> <span class="m">80</span>
      <span class="na">nodePort</span><span class="pi">:</span> <span class="m">58180</span>
    <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">https</span>
      <span class="na">port</span><span class="pi">:</span> <span class="m">443</span>
      <span class="na">nodePort</span><span class="pi">:</span> <span class="m">58181</span>
    <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">dashboard</span>
      <span class="na">port</span><span class="pi">:</span> <span class="m">8080</span>
      <span class="na">nodePort</span><span class="pi">:</span> <span class="m">58182</span>
  <span class="na">selector</span><span class="pi">:</span>
    <span class="na">app</span><span class="pi">:</span> <span class="s">traefik</span>
</pre></table></code></div></div><p>基于traefik镜像启动的pod将创建运行三个端口服务，80和443对应ingress本身核心服务，我们后续可以将流量都转发到ingress的80端口，让ingress做流量调度。8080是traefik的控制面板后台服务。</p><p>我们定义了3个nodePort类型的service，目的是为了在每个工作节点上提供一个服务入口。后续再将请求负载到各个节点上。创建好配置文件后，执行以下命令启动服务</p><div class="language-shell highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>kubectl apply <span class="nt">-f</span> traefik.yml
</pre></table></code></div></div><p>此时我们通过 <code class="language-plaintext highlighter-rouge">kubectl get svc -A -o wide | grep traefik</code> 命令可以看到如下结果</p><div class="language-shell highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>kube-system   traefik      NodePort    10.96.71.38   &lt;none&gt;        80:58180/TCP,443:58181/TCP,8080:58182/TCP   116s
</pre></table></code></div></div><p>我们可以使用<code class="language-plaintext highlighter-rouge">ipvsadm -L</code>查看所有端口映射关系，现在我们在浏览器访问不同的工作节点上IP的<code class="language-plaintext highlighter-rouge">58180</code>端口，都会看到traefik的管理页面，代表安装成功。我们可以看到，集群节点端口与trafik端口的对应关系如下：</p><div class="table-wrapper"><table><thead><tr><th>集群节点端口<th>Traefik端口<tbody><tr><td>58180<td>80<tr><td>58181<td>443<tr><td>58182<td>8080</table></div><p>集群节点的端口由我们自定义，而traefik的8080端口是控制面板端口，80和443则是常见web服务的默认端口。</p><h3 id="142-配置负载均衡"><span class="mr-2">14.2 配置负载均衡</span><a href="#142-配置负载均衡" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>我们在<code class="language-plaintext highlighter-rouge">k8s-101</code>、<code class="language-plaintext highlighter-rouge">k8s-102</code>节点上分别创建了nginx服务，现在我们将流量转发到这2个工作节点上，假设我们的业务服务器是<code class="language-plaintext highlighter-rouge">algs.tech</code>，在<code class="language-plaintext highlighter-rouge">nginx</code>服务器添加以下配置</p><div class="language-ini highlighter-rouge"><div class="code-header"> <span data-label-text="Ini"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
</pre><td class="rouge-code"><pre><span class="na">upstream</span><span class="w"> </span><span class="na">traefik_dashboard</span><span class="w"> </span><span class="na">{</span><span class="w">
    </span><span class="na">server</span><span class="w"> </span><span class="na">192.168.122.102:58182</span><span class="w">    </span><span class="py">max_fails</span><span class="p">=</span><span class="s">3 fail_timeout=10s;</span>
<span class="w">    </span><span class="na">server</span><span class="w"> </span><span class="na">192.168.122.103:58182</span><span class="w">    </span><span class="py">max_fails</span><span class="p">=</span><span class="s">3 fail_timeout=10s;</span>
<span class="na">}</span><span class="w">

</span><span class="na">server</span><span class="w"> </span><span class="na">{</span><span class="w">
    </span><span class="na">server_name</span><span class="w"> </span><span class="na">traefik.algs.tech</span><span class="c">;
</span><span class="w">
    </span><span class="na">location</span><span class="w"> </span><span class="na">/</span><span class="w"> </span><span class="na">{</span><span class="w">
        </span><span class="na">proxy_pass</span><span class="w"> </span><span class="na">http://traefik_dashboard</span><span class="c">;
</span><span class="w">        </span><span class="na">proxy_set_header</span><span class="w"> </span><span class="na">Host</span><span class="w">       </span><span class="na">$http_host</span><span class="c">;
</span><span class="w">        </span><span class="na">proxy_set_header</span><span class="w"> </span><span class="na">x-forwarded-for</span><span class="w"> </span><span class="na">$proxy_add_x_forwarded_for</span><span class="c">;
</span><span class="w">    </span><span class="na">}</span><span class="w">
</span><span class="na">}</span><span class="w">


</span><span class="na">upstream</span><span class="w"> </span><span class="na">traefik_http</span><span class="w"> </span><span class="na">{</span><span class="w">
    </span><span class="na">server</span><span class="w"> </span><span class="na">192.168.122.102:58180</span><span class="w">    </span><span class="py">max_fails</span><span class="p">=</span><span class="s">3 fail_timeout=10s;</span>
<span class="w">    </span><span class="na">server</span><span class="w"> </span><span class="na">192.168.122.103:58180</span><span class="w">    </span><span class="py">max_fails</span><span class="p">=</span><span class="s">3 fail_timeout=10s;</span>
<span class="na">}</span><span class="w">

</span><span class="na">server</span><span class="w"> </span><span class="na">{</span><span class="w">
    </span><span class="na">server_name</span><span class="w"> </span><span class="na">*.algs.tech</span><span class="c">;
</span><span class="w">    </span><span class="na">listen</span><span class="w"> </span><span class="na">80</span><span class="c">;
</span><span class="w">
    </span><span class="na">location</span><span class="w"> </span><span class="na">/</span><span class="w"> </span><span class="na">{</span><span class="w">
        </span><span class="na">proxy_pass</span><span class="w"> </span><span class="na">http://traefik_http</span><span class="c">;
</span><span class="w">        </span><span class="na">proxy_set_header</span><span class="w"> </span><span class="na">Host</span><span class="w">       </span><span class="na">$http_host</span><span class="c">;
</span><span class="w">        </span><span class="na">proxy_set_header</span><span class="w"> </span><span class="na">x-forwarded-for</span><span class="w"> </span><span class="na">$proxy_add_x_forwarded_for</span><span class="c">;
</span><span class="w">    </span><span class="na">}</span><span class="w">
</span><span class="na">}</span><span class="w">

</span><span class="na">upstream</span><span class="w"> </span><span class="na">traefik_https</span><span class="w"> </span><span class="na">{</span><span class="w">
    </span><span class="na">server</span><span class="w"> </span><span class="na">192.168.122.102:58181</span><span class="w">    </span><span class="py">max_fails</span><span class="p">=</span><span class="s">3 fail_timeout=10s;</span>
<span class="w">    </span><span class="na">server</span><span class="w"> </span><span class="na">192.168.122.103:58181</span><span class="w">    </span><span class="py">max_fails</span><span class="p">=</span><span class="s">3 fail_timeout=10s;</span>
<span class="na">}</span><span class="w">

</span><span class="na">server</span><span class="w"> </span><span class="na">{</span><span class="w">
    </span><span class="na">server_name</span><span class="w"> </span><span class="na">*.algs.tech</span><span class="c">;
</span><span class="w">    </span><span class="na">listen</span><span class="w"> </span><span class="na">443</span><span class="w"> </span><span class="na">ssl</span><span class="c">;
</span><span class="w">
    </span><span class="c"># ssl证书
</span><span class="w">    </span><span class="na">ssl_certificate</span><span class="w"> </span><span class="na">/etc/certs/ssl/algs.tech/fullchain.pem</span><span class="c">;
</span><span class="w">    </span><span class="na">ssl_certificate_key</span><span class="w"> </span><span class="na">/etc/certs/ssl/algs.tech/key.pem</span><span class="c">;
</span><span class="w">    </span><span class="na">ssl_session_timeout</span><span class="w">     </span><span class="na">5m</span><span class="c">;
</span><span class="w">
    </span><span class="na">ssl_protocols</span><span class="w"> </span><span class="na">TLSv1.2</span><span class="w"> </span><span class="na">TLSv1.3</span><span class="c">;
</span><span class="w">    </span><span class="na">ssl_ciphers</span><span class="w"> </span><span class="na">HIGH:!aNULL:!MD5</span><span class="c">;
</span><span class="w">    </span><span class="na">ssl_session_cache</span><span class="w"> </span><span class="na">shared:SSL:10m</span><span class="c">;
</span><span class="w">    </span><span class="na">ssl_prefer_server_ciphers</span><span class="w"> </span><span class="na">on</span><span class="c">;
</span><span class="w">
    </span><span class="na">location</span><span class="w"> </span><span class="na">/</span><span class="w"> </span><span class="na">{</span><span class="w">
        </span><span class="na">proxy_pass</span><span class="w"> </span><span class="na">http://traefik_https</span><span class="c">;
</span><span class="w">        </span><span class="na">proxy_set_header</span><span class="w"> </span><span class="na">Host</span><span class="w">       </span><span class="na">$http_host</span><span class="c">;
</span><span class="w">        </span><span class="na">proxy_set_header</span><span class="w"> </span><span class="na">x-forwarded-for</span><span class="w"> </span><span class="na">$proxy_add_x_forwarded_for</span><span class="c">;
</span><span class="w">    </span><span class="na">}</span><span class="w">
</span><span class="na">}</span><span class="w">
</span></pre></table></code></div></div><p>在以上配置中，我们把<code class="language-plaintext highlighter-rouge">traefik.algs.tech</code>的请求转发到traefik的控制面板。同时，我们把<code class="language-plaintext highlighter-rouge">*.algs.tech</code>的所有80端口和443端口的流量转发到集群对应的traefik服务，由traefik来调度，后续发布服务我们只需要配置好 <code class="language-plaintext highlighter-rouge">ingress</code> 资源即可。</p><p>至此，集群的核心组件和核心插件已经全部安装完毕。</p><h2 id="部署web服务"><span class="mr-2">部署web服务</span><a href="#部署web服务" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>在本节中，我们将部署一个简单的web服务，并通过<code class="language-plaintext highlighter-rouge">ingress</code>资源来发布到集群中。</p><h3 id="151-概述"><span class="mr-2">15.1 概述</span><a href="#151-概述" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>部署k8s通常包含以下几个步骤</p><ul><li>1.准备项目镜像，用于启动应用容器<li>2.通常创建Deployment资源的方式运行应用<li>3.创建应用的Service网络，用于关联Deployment<li>4.创建对应的Ingress资源，用于调度7层流量</ul><p>在下文，我们使用声明式的管理方式（通常指通过yaml配置文件来管理集群）来创建各个集群资源，完成应用部署。</p><h3 id="152-准备资源配置文件"><span class="mr-2">15.2 准备资源配置文件</span><a href="#152-准备资源配置文件" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>我们通过部署 nginx 来演示一个应用在k8s部署的流程</p><h4 id="1521-声明deployment"><span class="mr-2">15.2.1 声明deployment</span><a href="#1521-声明deployment" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>创建<code class="language-plaintext highlighter-rouge">whoami.yml</code>文件，添加以下内容</p><div class="language-yaml highlighter-rouge"><div class="code-header"> <span data-label-text="YAML"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre><td class="rouge-code"><pre><span class="na">kind</span><span class="pi">:</span> <span class="s">Deployment</span>
<span class="na">apiVersion</span><span class="pi">:</span> <span class="s">apps/v1</span>
<span class="na">metadata</span><span class="pi">:</span>
  <span class="na">name</span><span class="pi">:</span> <span class="s">whoami</span>
  <span class="na">labels</span><span class="pi">:</span>
    <span class="na">app</span><span class="pi">:</span> <span class="s">whoami</span>

<span class="na">spec</span><span class="pi">:</span>
  <span class="na">replicas</span><span class="pi">:</span> <span class="m">1</span>
  <span class="na">selector</span><span class="pi">:</span>
    <span class="na">matchLabels</span><span class="pi">:</span>
      <span class="na">app</span><span class="pi">:</span> <span class="s">whoami</span>
  <span class="na">template</span><span class="pi">:</span>
    <span class="na">metadata</span><span class="pi">:</span>
      <span class="na">labels</span><span class="pi">:</span>
        <span class="na">app</span><span class="pi">:</span> <span class="s">whoami</span>
    <span class="na">spec</span><span class="pi">:</span>
      <span class="na">containers</span><span class="pi">:</span>
        <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">whoami</span>
          <span class="na">image</span><span class="pi">:</span> <span class="s">nginx</span>
          <span class="na">ports</span><span class="pi">:</span>
            <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">web</span>
              <span class="na">containerPort</span><span class="pi">:</span> <span class="m">80</span>
</pre></table></code></div></div><h4 id="1522-声明service"><span class="mr-2">15.2.2 声明service</span><a href="#1522-声明service" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>创建<code class="language-plaintext highlighter-rouge">whoami-services.yml</code>文件，添加以下内容</p><div class="language-yml highlighter-rouge"><div class="code-header"> <span data-label-text="YAML"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre><span class="na">apiVersion</span><span class="pi">:</span> <span class="s">v1</span>
<span class="na">kind</span><span class="pi">:</span> <span class="s">Service</span>
<span class="na">metadata</span><span class="pi">:</span>
  <span class="na">name</span><span class="pi">:</span> <span class="s">whoami</span>

<span class="na">spec</span><span class="pi">:</span>
  <span class="na">ports</span><span class="pi">:</span>
    <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">web</span>
      <span class="na">port</span><span class="pi">:</span> <span class="m">80</span>
      <span class="na">targetPort</span><span class="pi">:</span> <span class="s">web</span>

  <span class="na">selector</span><span class="pi">:</span>
    <span class="na">app</span><span class="pi">:</span> <span class="s">whoami</span>
</pre></table></code></div></div><h4 id="1523-声明ingress"><span class="mr-2">15.2.3 声明ingress</span><a href="#1523-声明ingress" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>创建<code class="language-plaintext highlighter-rouge">whoami-ingress.yml</code>，添加以下内容</p><div class="language-yml highlighter-rouge"><div class="code-header"> <span data-label-text="YAML"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre><td class="rouge-code"><pre><span class="na">apiVersion</span><span class="pi">:</span> <span class="s">networking.k8s.io/v1</span>
<span class="na">kind</span><span class="pi">:</span> <span class="s">Ingress</span>
<span class="na">metadata</span><span class="pi">:</span>
  <span class="na">name</span><span class="pi">:</span> <span class="s">whoami-ingress</span>
<span class="na">spec</span><span class="pi">:</span>
  <span class="na">rules</span><span class="pi">:</span>
  <span class="pi">-</span> <span class="na">host</span><span class="pi">:</span> <span class="s">nginx.algs.tech</span>
    <span class="na">http</span><span class="pi">:</span>
      <span class="na">paths</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="na">path</span><span class="pi">:</span> <span class="s">/</span>
        <span class="na">pathType</span><span class="pi">:</span> <span class="s">Prefix</span>
        <span class="na">backend</span><span class="pi">:</span>
          <span class="na">service</span><span class="pi">:</span>
            <span class="na">name</span><span class="pi">:</span> <span class="s">whoami</span>
            <span class="na">port</span><span class="pi">:</span>
              <span class="na">name</span><span class="pi">:</span> <span class="s">web</span>
</pre></table></code></div></div><h3 id="153-资源创建与验证"><span class="mr-2">15.3 资源创建与验证</span><a href="#153-资源创建与验证" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>创建各个资源</p><div class="language-bash highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre>kubectl apply <span class="nt">-f</span> whoami.yml <span class="se">\</span>
              <span class="nt">-f</span> whoami-services.yml <span class="se">\</span>
              <span class="nt">-f</span> whoami-ingress.yml
</pre></table></code></div></div><p>执行以上命令之后，k8s将会拉取 nginx 的镜像，并按我们指定的配置去启动服务。</p><p>启动完成之后，我们在自己的桌面操作系统的电脑上将<code class="language-plaintext highlighter-rouge">nginx.algs.tech</code>域名解析到在前面通过 <code class="language-plaintext highlighter-rouge">keepalived</code> 创建的虚拟IP <code class="language-plaintext highlighter-rouge">192.168.122.100</code>，再使用浏览器访问域名，就顺利访问到了nginx的首页了。</p></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/%E5%B7%A5%E5%85%B7/'>工具</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/kubernetes/" class="post-tag no-text-decoration" >kubernetes</a> <a href="/tags/k8s/" class="post-tag no-text-decoration" >k8s</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> 本文由作者按照 <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> 进行授权</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">分享</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=%E5%9C%A8%20Debian%2012%20%E4%B8%8A%E5%AE%8C%E5%85%A8%E6%89%8B%E5%8A%A8%E5%AE%89%E8%A3%85%20kubernetes%20v1.32.2%20-%20%E6%9E%81%E5%AE%A2%E5%BC%80%E5%8F%91%E8%80%85-%E5%8D%9A%E5%AE%A2&url=https%3A%2F%2Fblog.algs.tech%2Fposts%2Ftools_Fully-Manual-Installation-of-Kubernetes-v1.32.2-on-Debian-12.md-copy.html" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=%E5%9C%A8%20Debian%2012%20%E4%B8%8A%E5%AE%8C%E5%85%A8%E6%89%8B%E5%8A%A8%E5%AE%89%E8%A3%85%20kubernetes%20v1.32.2%20-%20%E6%9E%81%E5%AE%A2%E5%BC%80%E5%8F%91%E8%80%85-%E5%8D%9A%E5%AE%A2&u=https%3A%2F%2Fblog.algs.tech%2Fposts%2Ftools_Fully-Manual-Installation-of-Kubernetes-v1.32.2-on-Debian-12.md-copy.html" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://t.me/share/url?url=https%3A%2F%2Fblog.algs.tech%2Fposts%2Ftools_Fully-Manual-Installation-of-Kubernetes-v1.32.2-on-Debian-12.md-copy.html&text=%E5%9C%A8%20Debian%2012%20%E4%B8%8A%E5%AE%8C%E5%85%A8%E6%89%8B%E5%8A%A8%E5%AE%89%E8%A3%85%20kubernetes%20v1.32.2%20-%20%E6%9E%81%E5%AE%A2%E5%BC%80%E5%8F%91%E8%80%85-%E5%8D%9A%E5%AE%A2" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <a href="https://service.weibo.com/share/share.php?title=%E5%9C%A8%20Debian%2012%20%E4%B8%8A%E5%AE%8C%E5%85%A8%E6%89%8B%E5%8A%A8%E5%AE%89%E8%A3%85%20kubernetes%20v1.32.2%20-%20%E6%9E%81%E5%AE%A2%E5%BC%80%E5%8F%91%E8%80%85-%E5%8D%9A%E5%AE%A2&url=https%3A%2F%2Fblog.algs.tech%2Fposts%2Ftools_Fully-Manual-Installation-of-Kubernetes-v1.32.2-on-Debian-12.md-copy.html" data-toggle="tooltip" data-placement="top" title="Weibo" target="_blank" rel="noopener" aria-label="Weibo"> <i class="fa-fw fab fa-weibo"></i> </a> <i id="copy-link" class="fa-fw fas fa-link small" data-toggle="tooltip" data-placement="top" title="分享链接" data-title-succeed="链接已复制！"> </i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted"><div class="access"><div id="access-tags"><div class="panel-heading">热门标签</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/k8s/">k8s</a> <a class="post-tag" href="/tags/adb/">adb</a> <a class="post-tag" href="/tags/docker/">docker</a> <a class="post-tag" href="/tags/pingora/">Pingora</a> <a class="post-tag" href="/tags/posix/">POSIX</a> <a class="post-tag" href="/tags/%E5%8F%8C%E7%B3%BB%E7%BB%9F/">双系统</a> <a class="post-tag" href="/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA/">虚拟机</a> <a class="post-tag" href="/tags/android%E6%9D%83%E9%99%90/">android权限</a> <a class="post-tag" href="/tags/aosp/">aosp</a> <a class="post-tag" href="/tags/archlinux/">archlinux</a></div></div></div><div id="toc-wrapper" class="pl-0 pr-4 mb-5"><div class="panel-heading pl-3 pt-2 mb-2">文章内容</div><nav id="toc"></nav></div><script src="/assets/lib/tocbot/tocbot.min.js"></script></div></div><div class="row"><div id="tail-wrapper" class="col-12 col-lg-11 col-xl-9 pl-3 pr-3 pr-xl-4 mt-5"><div id="related-posts" class="mb-2 mb-sm-4"><h3 class="pt-2 mb-4 ml-1" data-toc-skip>相关文章</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/container_install-k8s-on-deepin-using-docker.html"><div class="card-body"> <em class="small" data-ts="1693199400" data-df="YYYY/MM/DD" > 2023/08/28 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>在Ubunt上快速搭建k8s集群</h3><div class="text-muted small"><p> 一、准备环境 撰写时间：2023-08-28 我们需要借助一个工具叫做minicuke，网址：https://minikube.sigs.k8s.io/，安装好minicube之后，我们可以安装单机的k8s环境，如下步骤 我的环境是： Deepin 20.9 (基于debian 10) 二、安装过程 2.1 删除旧环境 如果之前安装过，可以执行以下步骤 -- 删除ing...</p></div></div></a></div><div class="card"> <a href="/posts/container_install-etcd-cluster.html"><div class="card-body"> <em class="small" data-ts="1674888600" data-df="YYYY/MM/DD" > 2023/01/28 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>怎样安装etcd集群</h3><div class="text-muted small"><p> 撰写时间：2021-01-17，整理时间：2023-01-28 etcd可以用于k8s集群的数据库，下面是在内网安装etcd集群的详细步骤 一、为etcd颁发SSL证书 1.1 颁发步骤 加密证书我们可以向证书机构（CA）申请，但是由于我们部署在内网，我们自己自己创建一个CA后给自己颁发证书，步骤如下 （1）创建证书颁发机构 （2）填写表单–写明etcd所在节点的...</p></div></div></a></div><div class="card"> <a href="/posts/container_install-k8s-quickly-on-ubuntu.html"><div class="card-body"> <em class="small" data-ts="1674888660" data-df="YYYY/MM/DD" > 2023/01/28 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>在Ubuntu上快速搭建k8s集群</h3><div class="text-muted small"><p> 撰写时间：2021-01-17，整理时间：2023-01-28 etcd可以用于k8s集群的数据库，下面是在内网安装etcd集群的详细步骤 一、为etcd颁发SSL证书 1.1 颁发步骤 加密证书我们可以向证书机构（CA）申请，但是由于我们部署在内网，我们自己自己创建一个CA后给自己颁发证书，步骤如下 （1）创建证书颁发机构 （2）填写表单–写明etcd所在节点的...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/database_install-postgresql-on-debian-using-apt.html" class="btn btn-outline-primary" prompt="上一篇"><p>在Debian上使用安装PostgreSQL数据库</p></a> <a href="/posts/tools_docker-compose-deploy-openldap-and-password-self-service-guide.md.html" class="btn btn-outline-primary" prompt="下一篇"><p>Docker-Compose 部署 OpenLDAP 与密码自助找回服务教程</p></a></div><script type="text/javascript"> $(function () { const origin = "https://giscus.app"; const iframe = "iframe.giscus-frame"; const lightTheme = "light"; const darkTheme = "dark_dimmed"; let initTheme = lightTheme; if ($("html[data-mode=dark]").length > 0 || ($("html[data-mode]").length == 0 && window.matchMedia("(prefers-color-scheme: dark)").matches)) { initTheme = darkTheme; } let giscusAttributes = { "src": "https://giscus.app/client.js", "data-repo": "geekdex/blog", "data-repo-id": "R_kgDOIyxhcQ", "data-category": "General", "data-category-id": "DIC_kwDOIyxhcc4CUhya", "data-mapping": "pathname", "data-reactions-enabled": "anonymous", "data-emit-metadata": "0", "data-theme": initTheme, "data-input-position": "0", "data-lang": "zh-CN", "crossorigin": "anonymous", "async": "" }; let giscusScript = document.createElement("script"); Object.entries(giscusAttributes).forEach(([key, value]) => giscusScript.setAttribute(key, value)); document.getElementById("tail-wrapper").appendChild(giscusScript); addEventListener("message", (event) => { if (event.source === window && event.data && event.data.direction === ModeToggle.ID) { /* global theme mode changed */ const mode = event.data.message; const theme = (mode === ModeToggle.DARK_MODE ? darkTheme : lightTheme); const message = { setConfig: { theme: theme } }; const giscus = document.querySelector(iframe).contentWindow; giscus.postMessage({ giscus: message }, origin); } }); }); </script></div></div></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><div id="access-tags"><div class="panel-heading">热门标签</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/k8s/">k8s</a> <a class="post-tag" href="/tags/adb/">adb</a> <a class="post-tag" href="/tags/docker/">docker</a> <a class="post-tag" href="/tags/pingora/">Pingora</a> <a class="post-tag" href="/tags/posix/">POSIX</a> <a class="post-tag" href="/tags/%E5%8F%8C%E7%B3%BB%E7%BB%9F/">双系统</a> <a class="post-tag" href="/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA/">虚拟机</a> <a class="post-tag" href="/tags/android%E6%9D%83%E9%99%90/">android权限</a> <a class="post-tag" href="/tags/aosp/">aosp</a> <a class="post-tag" href="/tags/archlinux/">archlinux</a></div></div></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><footer><div class="container pl-lg-4 pr-lg-4"><div class="d-flex justify-content-between align-items-center text-muted ml-md-3 mr-md-3"><div class="footer-left"><p class="mb-0"> © 2026 <a href="https://blog.algs.tech">blog.algs.tech</a>. <span data-toggle="tooltip" data-placement="top" title="除非另有说明，本网站上的博客文章均由作者按照知识共享署名 4.0 国际 (CC BY 4.0) 许可协议进行授权。">保留部分权利。</span></p></div><div class="footer-right"><p class="mb-0">本站由 <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> 生成，采用 <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> 主题。</p></div></div></div></footer><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a><div id="notification" class="toast" role="alert" aria-live="assertive" aria-atomic="true" data-animation="true" data-autohide="false"><div class="toast-header"> <button type="button" class="ml-2 ml-auto close" data-dismiss="toast" aria-label="Close"> <span aria-hidden="true">&times;</span> </button></div><div class="toast-body text-center pt-0"><p class="pl-2 pr-2 mb-3">发现新版本的内容。</p><button type="button" class="btn btn-primary" aria-label="Update"> 更新 </button></div></div><script src="/assets/dist/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">搜索结果为空</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script src="/assets/dist/jquery.magnific-popup.min.js"></script> <script src="/assets/dist/lazysizes.min.js"></script> <script src="/assets/dist/clipboard.min.js"></script> <script src="/assets/dist/dayjs.min.js"></script> <script src="/assets/dist/locale/zh.min.js"></script> <script src="/assets/dist/relativeTime.min.js"></script> <script src="/assets/dist/localizedFormat.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script src="/assets/dist/bootstrap.bundle.min.js"></script> <script defer src="/app.js"></script>
