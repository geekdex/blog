<!DOCTYPE html><html lang="zh-CN" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="theme-color" media="(prefers-color-scheme: light)" content="#f7f7f7"><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1b1b1e"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"><meta name="viewport" content="width=device-width, user-scalable=no initial-scale=1, shrink-to-fit=no, viewport-fit=cover" ><meta name="generator" content="Jekyll v4.4.1" /><meta property="og:title" content="从线性连续存储开始，重新认识《数据结构》" /><meta property="og:locale" content="zh_CN" /><meta name="description" content="撰写时间：2019-06-13，整理时间：2023-01-26" /><meta property="og:description" content="撰写时间：2019-06-13，整理时间：2023-01-26" /><link rel="canonical" href="https://blog.algs.tech/posts/algorithm_linear-list.html" /><meta property="og:url" content="https://blog.algs.tech/posts/algorithm_linear-list.html" /><meta property="og:site_name" content="极客开发者-博客" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2023-01-26T21:28:00+08:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="从线性连续存储开始，重新认识《数据结构》" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2023-01-26T21:28:00+08:00","datePublished":"2023-01-26T21:28:00+08:00","description":"撰写时间：2019-06-13，整理时间：2023-01-26","headline":"从线性连续存储开始，重新认识《数据结构》","mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.algs.tech/posts/algorithm_linear-list.html"},"url":"https://blog.algs.tech/posts/algorithm_linear-list.html"}</script><title>从线性连续存储开始，重新认识《数据结构》 | 极客开发者-博客</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="极客开发者-博客"><meta name="application-name" content="极客开发者-博客"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="stylesheet" href="/assets/dist/fonts/main.css"><link rel="stylesheet" href="/assets/dist/bootstrap.min.css"><link rel="stylesheet" href="/assets/dist/fontawesome.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="/assets/lib/tocbot/tocbot.min.css"><link rel="stylesheet" href="/assets/dist/magnific-popup.min.css"> <script src="/assets/dist/jquery.min.js"></script> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get MODE_ATTR() { return "data-mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } static get ID() { return "mode-toggle"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } let self = this; /* always follow the system prefers */ this.sysDarkPrefers.addEventListener('change', () => { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.notify(); }); } /* constructor() */ get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode === ModeToggle.DARK_MODE; } get isLightMode() { return this.mode === ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer)) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } setDark() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_ATTR); sessionStorage.removeItem(ModeToggle.MODE_KEY); } /* Notify another plugins that the theme mode has changed */ notify() { window.postMessage({ direction: ModeToggle.ID, message: this.modeStatus }, "*"); } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } this.notify(); } /* flipMode() */ } /* ModeToggle */ const modeToggle = new ModeToggle(); </script><body data-topbar-visible="true"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" class="mx-auto"> <img src="/img/about/avatar.jpeg" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title"> <a href="/">极客开发者-博客</a></div><div class="site-subtitle font-italic">在探索未知与梦想的道路上，让我们拥有共同的称呼 -- 开发者</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>首页</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>分类</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tag ml-xl-3 mr-xl-3 unloaded"></i> <span>标签</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>归档</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info-circle ml-xl-3 mr-xl-3 unloaded"></i> <span>关于</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center align-items-center"> <button class="mode-toggle btn" aria-label="Switch Mode"> <i class="fas fa-adjust"></i> </button> <span class="icon-border"></span> <a href="https://github.com/geekdex" aria-label="github" target="_blank" rel="noopener noreferrer"> <i class="fab fa-github"></i> </a> <a href="javascript:location.href = 'mailto:' + ['pan.hy','foxmail.com'].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" > <i class="fas fa-rss"></i> </a></div></div><div id="topbar-wrapper"><div id="topbar" class="container d-flex align-items-center justify-content-between h-100 pl-3 pr-3 pl-md-4 pr-md-4"> <span id="breadcrumb"> <span> <a href="/"> 首页 </a> </span> <span>从线性连续存储开始，重新认识《数据结构》</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> 文章</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="搜索..."> </span> <span id="search-cancel" >取消</span></div></div><div id="main-wrapper" class="d-flex justify-content-center"><div id="main" class="container pl-xl-4 pr-xl-4"><div class="row"><div id="core-wrapper" class="col-12 col-lg-11 col-xl-9 pr-xl-4"><div class="post pl-1 pr-1 pl-md-2 pr-md-2"><h1 data-toc-skip>从线性连续存储开始，重新认识《数据结构》</h1><div class="post-meta text-muted"> <span> 发表于 <em class="" data-ts="1674739680" data-df="YYYY/MM/DD" data-toggle="tooltip" data-placement="bottom"> 2023/01/26 </em> </span> <span style="float: right;"> <a href="https://lab.aoco.tech/convert?url=https://raw.githubusercontent.com/geekdex/blog/refs/heads/main/_posts/2023-01-26-algorithm_linear-list.md" class="view-source" target="_blank" style="color: #2a5caa; text-decoration: none; font-weight: 500;"> 查看Codelabs </a> &nbsp;|&nbsp; <a href="https://github.com/geekdex/blog/blob/main/_posts/2023-01-26-algorithm_linear-list.md" class="view-source" target="_blank" style="color: #2a5caa; text-decoration: none; font-weight: 500;"> 查看源码 </a> </span><div class="d-flex justify-content-between"> <span> 作者 <em> <a href="https://blog.algs.tech">blog.algs.tech</a> </em> </span><div> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="3590 字"> <em>19 分钟</em>阅读</span></div></div></div><div class="post-content"><blockquote><p>撰写时间：2019-06-13，整理时间：2023-01-26</p></blockquote><h2 id="一数据结构概述"><span class="mr-2">一、数据结构概述</span><a href="#一数据结构概述" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><h3 id="11-简介"><span class="mr-2">1.1 简介</span><a href="#11-简介" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>《数据结构》这门课程大多时候等同于《数据结构与算法》，所以我们一般说数据结构，都会涉及到算法。《数据结构》这门课程要求学生根据所学的数据结构理论，能完成复杂的程序设计。而程序设计能力的提高，必须要有学习、观摩、借鉴和实践的过程。</p><p>在阅读这篇文章时，你应当具备一定的C/C++编程基础，并能够理解指针和结构体。</p><h3 id="12-数据结构与算法的概念"><span class="mr-2">1.2 数据结构与算法的概念</span><a href="#12-数据结构与算法的概念" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>我们把现实中复杂的问题以特定的数据类型（现实中的个体）和特定的存储结构（现实中个体之间的关系）保存在计算机内存中，我们把这种“特定的存储结构”叫做数据结构。在此数据结构的基础之上为实现的某个功能（比如查找、删除、排序）而执行的相应操作叫做算法。</p><blockquote><p>我们可以简单理解为：数据结构 = 个体 + 个体的关系，算法 = 对存储数据的操作。</p></blockquote><h3 id="13-衡量算法的标准"><span class="mr-2">1.3 衡量算法的标准</span><a href="#13-衡量算法的标准" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>通过1，我们把处理数据的方法和步骤叫做算法。而衡量算法的标准包括以下几个方面：</p><ul><li>时间复杂度：程序大概要执行的次数，而非执行的时间<li>空间复杂度：算法执行过程中，大概占用的最大的内存<li>难易程度<li>健壮性</ul><blockquote><p>算法最核心的内容是研究算法的时间复杂度和空间复杂度。</p></blockquote><h3 id="14-数据结构在程序开发中的地位"><span class="mr-2">1.4 数据结构在程序开发中的地位</span><a href="#14-数据结构在程序开发中的地位" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>数据结构是软件工程中最核心的课程。在实际程序开发中，我们会使用各种编程语言，对各种数据进行相应的功能操作，如存储、查询、删除，或是更复杂的运算。所以数据结构功底在一定程度上，决定了个人在程序开发上的综合能力。</p><blockquote><p>我们可以理解为：程序 = 数据的存储 + 数据的操作（也就是算法） + 可以被计算机执行的语言。</p></blockquote><h3 id="15-数据结构的基本模块"><span class="mr-2">1.5 数据结构的基本模块</span><a href="#15-数据结构的基本模块" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>为了方便我们今后的学习，本文列出数据结构的基础知识模块如下</p><p>线性结构（我们可以把它叫做线性表）</p><ul><li>连续存储[数组]<li>离散存储[链表]<li>线性结构的两种常见应用之一——栈<li>线性结构的两种常见应用之二——队列</ul><p>非线性结构</p><ul><li>树<li>图</ul><h2 id="二连续存储的数据结构与基本算法"><span class="mr-2">二、连续存储的数据结构与基本算法</span><a href="#二连续存储的数据结构与基本算法" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><blockquote><p>在数据结构中，我们研究的对象就是数据，其次是研究操作数据的方法与步骤。今天，我们从线性结构中的连续存储开始，从代码的角度，重新认识数据结构。</p></blockquote><p>连续存储实际上就是连续的存储结构，我们可以理解数组就是连续存储的实现。接下来我们通过C语言的<code class="language-plaintext highlighter-rouge">struct</code>关键字，定义连续存储这种数据结构体，这里我们把它叫做数组，并研究其基本的算法。</p><p>连续存储结构容易实现元素的追和读取线性表中的第 i 个元素的操作；但在实现插入、删除操作时，需要移动大量元素。所以，它适合存储相对稳定的线性表，如职工工资表、学生学籍表。</p><h3 id="21-定义数组"><span class="mr-2">2.1 定义数组</span><a href="#21-定义数组" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>首先我们定义一个<code class="language-plaintext highlighter-rouge">01-Arr.cpp</code>文件，需要引入基本的c语言头文件，如下代码</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="cp"># include &lt;stdio.h&gt; // 标准io头部，包含printf函数
# include &lt;malloc.h&gt; // 包含malloc函数，在mac电脑上，改为sys/malloc.h
# include &lt;stdlib.h&gt; // 包含exit函数
</span></pre></table></code></div></div><p>接下来我们定义数组的结构体，该数据类型包含三个成员，pBase、len、cnt，如下代码</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="k">struct</span> <span class="n">Arr</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="o">*</span><span class="n">pBase</span><span class="p">;</span> <span class="c1">// 存储的是数组第一个元素的地址</span>
    <span class="kt">int</span> <span class="n">len</span><span class="p">;</span>    <span class="c1">// 数组所能容纳的最大元素个数</span>
    <span class="kt">int</span> <span class="n">cnt</span><span class="p">;</span>    <span class="c1">// 当前数组有效元素个数</span>
<span class="p">};</span>
</pre></table></code></div></div><h3 id="22-初始化数组"><span class="mr-2">2.2 初始化数组</span><a href="#22-初始化数组" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>接下来我们定义初始化数组的函数，根据数组长度动态分配内存，用于存储对应的数组元素，如下代码</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre><td class="rouge-code"><pre><span class="kt">void</span> <span class="nf">init_arr</span><span class="p">(</span><span class="k">struct</span> <span class="n">Arr</span> <span class="o">*</span><span class="n">pArr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">length</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// 根据数组的长度，分配的内存pBase</span>
    <span class="n">pArr</span><span class="o">-&gt;</span><span class="n">pBase</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="o">*</span> <span class="n">length</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="nb">NULL</span> <span class="o">==</span> <span class="n">pArr</span><span class="o">-&gt;</span><span class="n">pBase</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"动态分配内存失败"</span><span class="p">);</span>
        <span class="n">exit</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="c1">// 内存分配成功</span>
    <span class="n">pArr</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">=</span> <span class="n">length</span><span class="p">;</span>
    <span class="n">pArr</span><span class="o">-&gt;</span><span class="n">cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">return</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><h3 id="23-判定数组是否为空或是否已满"><span class="mr-2">2.3 判定数组是否为空或是否已满</span><a href="#23-判定数组是否为空或是否已满" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>我们可以根据当前数组的有效元素和数组总元素判定数组是否为空或者是否已满，定义以下两个函数</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
</pre><td class="rouge-code"><pre><span class="c1">// 判断数组是否为空</span>
<span class="n">bool</span> <span class="nf">is_empty</span><span class="p">(</span><span class="k">struct</span> <span class="n">Arr</span> <span class="o">*</span><span class="n">pArr</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// 数组的有效个数为0，即数组为空</span>
    <span class="k">if</span> <span class="p">(</span><span class="mi">0</span> <span class="o">==</span> <span class="n">pArr</span><span class="o">-&gt;</span><span class="n">cnt</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="c1">// 否则，数组不为空</span>
    <span class="k">else</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="c1">// 判断数组是否已满</span>
<span class="n">bool</span> <span class="nf">is_full</span><span class="p">(</span><span class="k">struct</span> <span class="n">Arr</span> <span class="o">*</span><span class="n">pArr</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// 数组的有效个数为数组的长度，即数组已满</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">pArr</span><span class="o">-&gt;</span><span class="n">cnt</span> <span class="o">==</span> <span class="n">pArr</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="c1">// 否则，数组未满</span>
    <span class="k">else</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><h3 id="24-遍历数组元素"><span class="mr-2">2.4 遍历数组元素</span><a href="#24-遍历数组元素" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>遍历数组的目的是把每一个有效的数组元素打印到终端。根据数组的当前有效个数，遍历并打印每个元素，我们定义如下代码</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="kt">void</span> <span class="nf">traverse_arr</span><span class="p">(</span><span class="k">struct</span> <span class="n">Arr</span> <span class="o">*</span><span class="n">pArr</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">pArr</span><span class="o">-&gt;</span><span class="n">cnt</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"%d</span><span class="se">\t</span><span class="s">"</span><span class="p">,</span> <span class="n">pArr</span><span class="o">-&gt;</span><span class="n">pBase</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
    <span class="p">}</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><h3 id="25-追加数组元素"><span class="mr-2">2.5 追加数组元素</span><a href="#25-追加数组元素" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>追加即在未满的数组中，在末尾添加元素，如下代码</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre><span class="n">bool</span> <span class="nf">append_arr</span><span class="p">(</span><span class="k">struct</span> <span class="n">Arr</span> <span class="o">*</span><span class="n">pArr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// 数组已满则返回false</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">is_full</span><span class="p">(</span><span class="n">pArr</span><span class="p">))</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="c1">// 数组不满时进行追加</span>
    <span class="n">pArr</span><span class="o">-&gt;</span><span class="n">pBase</span><span class="p">[</span><span class="n">pArr</span><span class="o">-&gt;</span><span class="n">cnt</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>
    <span class="p">(</span><span class="n">pArr</span><span class="o">-&gt;</span><span class="n">cnt</span><span class="p">)</span><span class="o">++</span><span class="p">;</span>
    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><h3 id="26-插入元素"><span class="mr-2">2.6 插入元素</span><a href="#26-插入元素" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>数组除了追加，还有数组插入操作，插入即在特定的位置添加数据，如下代码</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre><td class="rouge-code"><pre><span class="n">bool</span> <span class="nf">insert_arr</span><span class="p">(</span><span class="k">struct</span> <span class="n">Arr</span> <span class="o">*</span><span class="n">pArr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">pos</span><span class="p">,</span> <span class="kt">int</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// 如果数组元素已满，返回false</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">is_full</span><span class="p">(</span><span class="n">pArr</span><span class="p">))</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="c1">// 如果要插入的位置不对，返回false</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">pos</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">pos</span> <span class="o">&gt;</span> <span class="n">pArr</span><span class="o">-&gt;</span><span class="n">cnt</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="c1">// 从最后一个元素的位置开始，到要插入的位置，挨个将数组元素往后移一位</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">pArr</span><span class="o">-&gt;</span><span class="n">cnt</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="n">pos</span><span class="p">;</span> <span class="o">--</span><span class="n">i</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">pArr</span><span class="o">-&gt;</span><span class="n">pBase</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">pArr</span><span class="o">-&gt;</span><span class="n">pBase</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
    <span class="p">}</span>
    <span class="c1">// 将插入的值，赋在指定的位置</span>
    <span class="n">pArr</span><span class="o">-&gt;</span><span class="n">pBase</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>
    <span class="c1">// 标记数组有效元素的字段加1</span>
    <span class="p">(</span><span class="n">pArr</span><span class="o">-&gt;</span><span class="n">cnt</span><span class="p">)</span><span class="o">++</span><span class="p">;</span>
    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><h3 id="27-删除元素"><span class="mr-2">2.7 删除元素</span><a href="#27-删除元素" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>删除操作和插入操作类似，区别是：插入数据时，从插入位置开始，后面的数据往后移，并在插入的位置加入元素；删除数据时，我们需要在删除位置的后一位开始，后面的数据都往前移，删除位置的数据会被覆盖，如下代码</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
</pre><td class="rouge-code"><pre><span class="n">bool</span> <span class="nf">delete_arr</span><span class="p">(</span><span class="k">struct</span> <span class="n">Arr</span> <span class="o">*</span><span class="n">pArr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">pos</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">pVal</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// 如果数组元素已满，返回false</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">is_full</span><span class="p">(</span><span class="n">pArr</span><span class="p">))</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="c1">// 如果要插入的位置不对，返回false</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">pos</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">pos</span> <span class="o">&gt;</span> <span class="n">pArr</span><span class="o">-&gt;</span><span class="n">cnt</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="c1">// 将删除的元素的值赋给传进来的指针变量</span>
    <span class="o">*</span><span class="n">pVal</span> <span class="o">=</span> <span class="n">pArr</span><span class="o">-&gt;</span><span class="n">pBase</span><span class="p">[</span><span class="n">pos</span><span class="p">];</span>
    <span class="c1">// 从到要删除的位置开始，一直到最后一个位置，将数组元素挨个往前移动</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">pos</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">pArr</span><span class="o">-&gt;</span><span class="n">cnt</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">pArr</span><span class="o">-&gt;</span><span class="n">pBase</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">pArr</span><span class="o">-&gt;</span><span class="n">pBase</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
    <span class="p">}</span>
    <span class="n">pArr</span><span class="o">-&gt;</span><span class="n">cnt</span><span class="o">--</span><span class="p">;</span>
    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><h3 id="28-数组倒置"><span class="mr-2">2.8 数组倒置</span><a href="#28-数组倒置" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>数组倒置的操作是将数组的第1位和最后1位元素进行替换，第2位和倒数第2位元素进行替换，依此类推。最终完成倒置，如下代码</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre><td class="rouge-code"><pre><span class="kt">void</span> <span class="nf">inverse_arr</span><span class="p">(</span><span class="k">struct</span> <span class="n">Arr</span> <span class="o">*</span><span class="n">pArr</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">pArr</span><span class="o">-&gt;</span><span class="n">cnt</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">t</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">j</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">t</span> <span class="o">=</span> <span class="n">pArr</span><span class="o">-&gt;</span><span class="n">pBase</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
        <span class="n">pArr</span><span class="o">-&gt;</span><span class="n">pBase</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">pArr</span><span class="o">-&gt;</span><span class="n">pBase</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
        <span class="n">pArr</span><span class="o">-&gt;</span><span class="n">pBase</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">t</span><span class="p">;</span>
        <span class="o">++</span><span class="n">i</span><span class="p">;</span>
        <span class="o">--</span><span class="n">j</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><h3 id="29-数组排序"><span class="mr-2">2.9 数组排序</span><a href="#29-数组排序" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>接下来是一个简单的排序过程，函数中有两层循环。第一层循环，选择当前位置的元素（从索引为0的位置开始，即未循环前，当前位置是第1个元素），在第二层循环中，从当前位置的元素的下一个元素开始，直到最后一个元素，挨个与当前位置的元素进行大小对比，每次对比都把小的元素替换到当前位置。</p><p>第1轮循环结束后，索引为0的位置将是最小的元素，第2轮循环结束后，索引为1的位置将是次小的元素，依此类推。最终，数组元素将按从小到大的顺序排列，如下代码</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre><td class="rouge-code"><pre><span class="kt">void</span> <span class="nf">sort_arr</span><span class="p">(</span><span class="k">struct</span> <span class="n">Arr</span> <span class="o">*</span><span class="n">pArr</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">t</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">pArr</span><span class="o">-&gt;</span><span class="n">cnt</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">pArr</span><span class="o">-&gt;</span><span class="n">cnt</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">pArr</span><span class="o">-&gt;</span><span class="n">pBase</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">pArr</span><span class="o">-&gt;</span><span class="n">pBase</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
            <span class="p">{</span>
                <span class="n">t</span> <span class="o">=</span> <span class="n">pArr</span><span class="o">-&gt;</span><span class="n">pBase</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
                <span class="n">pArr</span><span class="o">-&gt;</span><span class="n">pBase</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">pArr</span><span class="o">-&gt;</span><span class="n">pBase</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
                <span class="n">pArr</span><span class="o">-&gt;</span><span class="n">pBase</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">t</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><h2 id="三测试与验证"><span class="mr-2">三、测试与验证</span><a href="#三测试与验证" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>最终所有测试代码如下</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148
149
150
151
152
153
154
155
156
157
158
159
160
161
162
163
164
165
166
167
168
169
170
171
172
173
174
175
176
177
178
179
180
181
182
183
184
185
186
187
188
189
190
191
192
193
194
195
196
197
198
199
200
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;sys/malloc.h&gt;</span><span class="c1"> // windows中用 #include &lt;malloc.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
</span>
<span class="c1">// 定义数组结构体</span>
<span class="k">struct</span> <span class="n">Arr</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="o">*</span><span class="n">pBase</span><span class="p">;</span> <span class="c1">// 存储的是数组第一个元素的地址</span>
    <span class="kt">int</span> <span class="n">len</span><span class="p">;</span>    <span class="c1">// 数组所能容纳的最大元素个数</span>
    <span class="kt">int</span> <span class="n">cnt</span><span class="p">;</span>    <span class="c1">// 当前数组有效元素个数</span>
<span class="p">};</span>

<span class="c1">// 初始化数组</span>
<span class="kt">void</span> <span class="nf">init_arr</span><span class="p">(</span><span class="k">struct</span> <span class="n">Arr</span> <span class="o">*</span><span class="n">pArr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">length</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// 将分配的内存赋给pBase</span>
    <span class="n">pArr</span><span class="o">-&gt;</span><span class="n">pBase</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="o">*</span> <span class="n">length</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="nb">NULL</span> <span class="o">==</span> <span class="n">pArr</span><span class="o">-&gt;</span><span class="n">pBase</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"动态分配内存失败"</span><span class="p">);</span>
        <span class="n">exit</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="c1">// 内存分配成功</span>
    <span class="n">pArr</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">=</span> <span class="n">length</span><span class="p">;</span>
    <span class="n">pArr</span><span class="o">-&gt;</span><span class="n">cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// 判断数组是否为空</span>
<span class="n">bool</span> <span class="nf">is_empty</span><span class="p">(</span><span class="k">struct</span> <span class="n">Arr</span> <span class="o">*</span><span class="n">pArr</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// 数组的有效个数为0，即数组为空</span>
    <span class="k">if</span> <span class="p">(</span><span class="mi">0</span> <span class="o">==</span> <span class="n">pArr</span><span class="o">-&gt;</span><span class="n">cnt</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="c1">// 否则，数组不为空</span>
    <span class="k">else</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// 判断数组元素是否已满</span>
<span class="n">bool</span> <span class="nf">is_full</span><span class="p">(</span><span class="k">struct</span> <span class="n">Arr</span> <span class="o">*</span><span class="n">pArr</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// 数组的有效个数为数组的长度，即数组已满</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">pArr</span><span class="o">-&gt;</span><span class="n">cnt</span> <span class="o">==</span> <span class="n">pArr</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="c1">// 否则，数组未满</span>
    <span class="k">else</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// 遍历数组</span>
<span class="kt">void</span> <span class="nf">traverse_arr</span><span class="p">(</span><span class="k">struct</span> <span class="n">Arr</span> <span class="o">*</span><span class="n">pArr</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">pArr</span><span class="o">-&gt;</span><span class="n">cnt</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"%d</span><span class="se">\t</span><span class="s">"</span><span class="p">,</span> <span class="n">pArr</span><span class="o">-&gt;</span><span class="n">pBase</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
    <span class="p">}</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// 追加数组（元素）</span>
<span class="n">bool</span> <span class="nf">append_arr</span><span class="p">(</span><span class="k">struct</span> <span class="n">Arr</span> <span class="o">*</span><span class="n">pArr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// 数组满是返回false</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">is_full</span><span class="p">(</span><span class="n">pArr</span><span class="p">))</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="c1">// 数组不满时追加</span>
    <span class="n">pArr</span><span class="o">-&gt;</span><span class="n">pBase</span><span class="p">[</span><span class="n">pArr</span><span class="o">-&gt;</span><span class="n">cnt</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>
    <span class="p">(</span><span class="n">pArr</span><span class="o">-&gt;</span><span class="n">cnt</span><span class="p">)</span><span class="o">++</span><span class="p">;</span>
    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// 插入数组（元素）</span>
<span class="n">bool</span> <span class="nf">insert_arr</span><span class="p">(</span><span class="k">struct</span> <span class="n">Arr</span> <span class="o">*</span><span class="n">pArr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">pos</span><span class="p">,</span> <span class="kt">int</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// 如果数组元素已满，返回false</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">is_full</span><span class="p">(</span><span class="n">pArr</span><span class="p">))</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="c1">// 如果要插入的位置不对，返回false</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">pos</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">pos</span> <span class="o">&gt;</span> <span class="n">pArr</span><span class="o">-&gt;</span><span class="n">cnt</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="c1">// 从最后一个元素的位置开始，到要插入的位置，挨个将数组元素往后移一位</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">pArr</span><span class="o">-&gt;</span><span class="n">cnt</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="n">pos</span><span class="p">;</span> <span class="o">--</span><span class="n">i</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">pArr</span><span class="o">-&gt;</span><span class="n">pBase</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">pArr</span><span class="o">-&gt;</span><span class="n">pBase</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
    <span class="p">}</span>
    <span class="c1">// 将插入的值，赋在指定的位置</span>
    <span class="n">pArr</span><span class="o">-&gt;</span><span class="n">pBase</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>
    <span class="c1">// 标记数组有效元素的字段加1</span>
    <span class="p">(</span><span class="n">pArr</span><span class="o">-&gt;</span><span class="n">cnt</span><span class="p">)</span><span class="o">++</span><span class="p">;</span>
    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// 删除数组（元素）</span>
<span class="n">bool</span> <span class="nf">delete_arr</span><span class="p">(</span><span class="k">struct</span> <span class="n">Arr</span> <span class="o">*</span><span class="n">pArr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">pos</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">pVal</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// 如果数组元素已满，返回false</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">is_full</span><span class="p">(</span><span class="n">pArr</span><span class="p">))</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="c1">// 如果要插入的位置不对，返回false</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">pos</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">pos</span> <span class="o">&gt;</span> <span class="n">pArr</span><span class="o">-&gt;</span><span class="n">cnt</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="c1">// 将删除的元素的值赋给传进来的指针变量</span>
    <span class="o">*</span><span class="n">pVal</span> <span class="o">=</span> <span class="n">pArr</span><span class="o">-&gt;</span><span class="n">pBase</span><span class="p">[</span><span class="n">pos</span><span class="p">];</span>
    <span class="c1">// 从到要删除的位置开始，一直到最后一个位置，将数组元素挨个往前移动</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">pos</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">pArr</span><span class="o">-&gt;</span><span class="n">cnt</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">pArr</span><span class="o">-&gt;</span><span class="n">pBase</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">pArr</span><span class="o">-&gt;</span><span class="n">pBase</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
    <span class="p">}</span>
    <span class="n">pArr</span><span class="o">-&gt;</span><span class="n">cnt</span><span class="o">--</span><span class="p">;</span>
    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// 倒置数组（元素）</span>
<span class="kt">void</span> <span class="nf">inverse_arr</span><span class="p">(</span><span class="k">struct</span> <span class="n">Arr</span> <span class="o">*</span><span class="n">pArr</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">pArr</span><span class="o">-&gt;</span><span class="n">cnt</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">t</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">j</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">t</span> <span class="o">=</span> <span class="n">pArr</span><span class="o">-&gt;</span><span class="n">pBase</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
        <span class="n">pArr</span><span class="o">-&gt;</span><span class="n">pBase</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">pArr</span><span class="o">-&gt;</span><span class="n">pBase</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
        <span class="n">pArr</span><span class="o">-&gt;</span><span class="n">pBase</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">t</span><span class="p">;</span>
        <span class="o">++</span><span class="n">i</span><span class="p">;</span>
        <span class="o">--</span><span class="n">j</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// 数组排序</span>
<span class="kt">void</span> <span class="nf">sort_arr</span><span class="p">(</span><span class="k">struct</span> <span class="n">Arr</span> <span class="o">*</span><span class="n">pArr</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">t</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">pArr</span><span class="o">-&gt;</span><span class="n">cnt</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">pArr</span><span class="o">-&gt;</span><span class="n">cnt</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">pArr</span><span class="o">-&gt;</span><span class="n">pBase</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">pArr</span><span class="o">-&gt;</span><span class="n">pBase</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
            <span class="p">{</span>
                <span class="n">t</span> <span class="o">=</span> <span class="n">pArr</span><span class="o">-&gt;</span><span class="n">pBase</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
                <span class="n">pArr</span><span class="o">-&gt;</span><span class="n">pBase</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">pArr</span><span class="o">-&gt;</span><span class="n">pBase</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
                <span class="n">pArr</span><span class="o">-&gt;</span><span class="n">pBase</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">t</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// 主函数测试</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">struct</span> <span class="n">Arr</span> <span class="n">arr</span><span class="p">;</span>
    <span class="c1">// 初始化长度为6的数组</span>
    <span class="n">init_arr</span><span class="p">(</span><span class="o">&amp;</span><span class="n">arr</span><span class="p">,</span> <span class="mi">6</span><span class="p">);</span>

    <span class="c1">// 追加元素</span>
    <span class="n">append_arr</span><span class="p">(</span><span class="o">&amp;</span><span class="n">arr</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
    <span class="n">append_arr</span><span class="p">(</span><span class="o">&amp;</span><span class="n">arr</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
    <span class="n">append_arr</span><span class="p">(</span><span class="o">&amp;</span><span class="n">arr</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
    <span class="n">append_arr</span><span class="p">(</span><span class="o">&amp;</span><span class="n">arr</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>

    <span class="n">traverse_arr</span><span class="p">(</span><span class="o">&amp;</span><span class="n">arr</span><span class="p">);</span> <span class="c1">// 输出结果为 1 2 3 4</span>

    <span class="c1">// 在索引为0的位置插入6</span>
    <span class="n">insert_arr</span><span class="p">(</span><span class="o">&amp;</span><span class="n">arr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">);</span>
    <span class="n">traverse_arr</span><span class="p">(</span><span class="o">&amp;</span><span class="n">arr</span><span class="p">);</span> <span class="c1">// 输出结果为 5 1 2 3 4</span>

    <span class="c1">// 在索引为0的位置删除元素</span>
    <span class="kt">int</span> <span class="n">delval</span><span class="p">;</span> <span class="c1">// 用于接收删除的元素</span>
    <span class="n">delete_arr</span><span class="p">(</span><span class="o">&amp;</span><span class="n">arr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">delval</span><span class="p">);</span>
    <span class="n">traverse_arr</span><span class="p">(</span><span class="o">&amp;</span><span class="n">arr</span><span class="p">);</span> <span class="c1">// 输出结果为 1 2 3 4</span>

    <span class="c1">// 数组倒置</span>
    <span class="n">inverse_arr</span><span class="p">(</span><span class="o">&amp;</span><span class="n">arr</span><span class="p">);</span>
    <span class="n">traverse_arr</span><span class="p">(</span><span class="o">&amp;</span><span class="n">arr</span><span class="p">);</span> <span class="c1">// 输出结果为 4 3 2 1</span>

    <span class="c1">// 数组排序</span>
    <span class="n">sort_arr</span><span class="p">(</span><span class="o">&amp;</span><span class="n">arr</span><span class="p">);</span>
    <span class="n">traverse_arr</span><span class="p">(</span><span class="o">&amp;</span><span class="n">arr</span><span class="p">);</span> <span class="c1">// 输出结果为 1 2 3 4</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><blockquote><p>本文原创首发自wx订阅号：<strong>极客开发中</strong>，禁止转载</p></blockquote></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/'>数据结构与算法</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> 本文由作者按照 <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> 进行授权</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">分享</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=%E4%BB%8E%E7%BA%BF%E6%80%A7%E8%BF%9E%E7%BB%AD%E5%AD%98%E5%82%A8%E5%BC%80%E5%A7%8B%EF%BC%8C%E9%87%8D%E6%96%B0%E8%AE%A4%E8%AF%86%E3%80%8A%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%8B%20-%20%E6%9E%81%E5%AE%A2%E5%BC%80%E5%8F%91%E8%80%85-%E5%8D%9A%E5%AE%A2&url=https%3A%2F%2Fblog.algs.tech%2Fposts%2Falgorithm_linear-list.html" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=%E4%BB%8E%E7%BA%BF%E6%80%A7%E8%BF%9E%E7%BB%AD%E5%AD%98%E5%82%A8%E5%BC%80%E5%A7%8B%EF%BC%8C%E9%87%8D%E6%96%B0%E8%AE%A4%E8%AF%86%E3%80%8A%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%8B%20-%20%E6%9E%81%E5%AE%A2%E5%BC%80%E5%8F%91%E8%80%85-%E5%8D%9A%E5%AE%A2&u=https%3A%2F%2Fblog.algs.tech%2Fposts%2Falgorithm_linear-list.html" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://t.me/share/url?url=https%3A%2F%2Fblog.algs.tech%2Fposts%2Falgorithm_linear-list.html&text=%E4%BB%8E%E7%BA%BF%E6%80%A7%E8%BF%9E%E7%BB%AD%E5%AD%98%E5%82%A8%E5%BC%80%E5%A7%8B%EF%BC%8C%E9%87%8D%E6%96%B0%E8%AE%A4%E8%AF%86%E3%80%8A%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%8B%20-%20%E6%9E%81%E5%AE%A2%E5%BC%80%E5%8F%91%E8%80%85-%E5%8D%9A%E5%AE%A2" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <a href="https://service.weibo.com/share/share.php?title=%E4%BB%8E%E7%BA%BF%E6%80%A7%E8%BF%9E%E7%BB%AD%E5%AD%98%E5%82%A8%E5%BC%80%E5%A7%8B%EF%BC%8C%E9%87%8D%E6%96%B0%E8%AE%A4%E8%AF%86%E3%80%8A%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%8B%20-%20%E6%9E%81%E5%AE%A2%E5%BC%80%E5%8F%91%E8%80%85-%E5%8D%9A%E5%AE%A2&url=https%3A%2F%2Fblog.algs.tech%2Fposts%2Falgorithm_linear-list.html" data-toggle="tooltip" data-placement="top" title="Weibo" target="_blank" rel="noopener" aria-label="Weibo"> <i class="fa-fw fab fa-weibo"></i> </a> <i id="copy-link" class="fa-fw fas fa-link small" data-toggle="tooltip" data-placement="top" title="分享链接" data-title-succeed="链接已复制！"> </i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted"><div class="access"><div id="access-tags"><div class="panel-heading">热门标签</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/k8s/">k8s</a> <a class="post-tag" href="/tags/adb/">adb</a> <a class="post-tag" href="/tags/docker/">docker</a> <a class="post-tag" href="/tags/pingora/">Pingora</a> <a class="post-tag" href="/tags/posix/">POSIX</a> <a class="post-tag" href="/tags/%E5%8F%8C%E7%B3%BB%E7%BB%9F/">双系统</a> <a class="post-tag" href="/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA/">虚拟机</a> <a class="post-tag" href="/tags/android%E6%9D%83%E9%99%90/">android权限</a> <a class="post-tag" href="/tags/aosp/">aosp</a> <a class="post-tag" href="/tags/archlinux/">archlinux</a></div></div></div><div id="toc-wrapper" class="pl-0 pr-4 mb-5"><div class="panel-heading pl-3 pt-2 mb-2">文章内容</div><nav id="toc"></nav></div><script src="/assets/lib/tocbot/tocbot.min.js"></script></div></div><div class="row"><div id="tail-wrapper" class="col-12 col-lg-11 col-xl-9 pl-3 pr-3 pr-xl-4 mt-5"><div id="related-posts" class="mb-2 mb-sm-4"><h3 class="pt-2 mb-4 ml-1" data-toc-skip>相关文章</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/algorithm_statement.html"><div class="card-body"> <em class="small" data-ts="1674048060" data-df="YYYY/MM/DD" > 2023/01/18 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>算法学习基础-基本概念</h3><div class="text-muted small"><p> 一、概述 撰写时间：2019-06-07 13:35，整理时间：2023-01-18 作为一名普通的二本学校，我在很早之前就有一个目标，那就是大学之后好好找一个软件开发工作。因此学习了很多的编程基础，不过近几天面试发现，技术官总是喜欢问你算法知识。编程语言不断变化，但是很底层的知识与算法密切相关，算法也就是体现程序员内功所在。因此，从此该好好学算法。 本笔记参考马士兵老师...</p></div></div></a></div><div class="card"> <a href="/posts/algorithm_sort.html"><div class="card-body"> <em class="small" data-ts="1674739620" data-df="YYYY/MM/DD" > 2023/01/26 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>算法学习基础-排序问题</h3><div class="text-muted small"><p> 撰写时间：2019-06-09，整理时间：2023-01-26，此博客参考以下内容 https://www.bilibili.com/video/av46648286 一、什么是排序问题？ 一系列没有顺序的数，从大到小或者从小到大进行排序，这就是排序问题。排序问题是最简单，最容易考到的问题。常见的排序如下图 我们应该至少记住四种排序，如下图 二、排序算法宋词记忆法 ...</p></div></div></a></div><div class="card"> <a href="/posts/algorithm_linked-list.html"><div class="card-body"> <em class="small" data-ts="1674740100" data-df="YYYY/MM/DD" > 2023/01/26 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>数据结构中的线性离散存储-链表</h3><div class="text-muted small"><p> 撰写时间：2019-06-28，整理时间：2023-01-26 一、概述 在上节，我们已经了解到了线性存储中的连续存储，我们还把这种存储结构叫做顺序表，或者数组。并且知道线性连续存储存在以下优缺点 优点：能实现快速追加和存取元素 缺点：插入元素或删除元素都要移动大量的原有元素 在本节，我们将一起来了解《数据结构》中研究的另一种线性数据结构-离散存储，我们也可以把线...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/algorithm_sort.html" class="btn btn-outline-primary" prompt="上一篇"><p>算法学习基础-排序问题</p></a> <a href="/posts/algorithm_linked-list.html" class="btn btn-outline-primary" prompt="下一篇"><p>数据结构中的线性离散存储-链表</p></a></div><script type="text/javascript"> $(function () { const origin = "https://giscus.app"; const iframe = "iframe.giscus-frame"; const lightTheme = "light"; const darkTheme = "dark_dimmed"; let initTheme = lightTheme; if ($("html[data-mode=dark]").length > 0 || ($("html[data-mode]").length == 0 && window.matchMedia("(prefers-color-scheme: dark)").matches)) { initTheme = darkTheme; } let giscusAttributes = { "src": "https://giscus.app/client.js", "data-repo": "geekdex/blog", "data-repo-id": "R_kgDOIyxhcQ", "data-category": "General", "data-category-id": "DIC_kwDOIyxhcc4CUhya", "data-mapping": "pathname", "data-reactions-enabled": "anonymous", "data-emit-metadata": "0", "data-theme": initTheme, "data-input-position": "0", "data-lang": "zh-CN", "crossorigin": "anonymous", "async": "" }; let giscusScript = document.createElement("script"); Object.entries(giscusAttributes).forEach(([key, value]) => giscusScript.setAttribute(key, value)); document.getElementById("tail-wrapper").appendChild(giscusScript); addEventListener("message", (event) => { if (event.source === window && event.data && event.data.direction === ModeToggle.ID) { /* global theme mode changed */ const mode = event.data.message; const theme = (mode === ModeToggle.DARK_MODE ? darkTheme : lightTheme); const message = { setConfig: { theme: theme } }; const giscus = document.querySelector(iframe).contentWindow; giscus.postMessage({ giscus: message }, origin); } }); }); </script></div></div></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><div id="access-tags"><div class="panel-heading">热门标签</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/k8s/">k8s</a> <a class="post-tag" href="/tags/adb/">adb</a> <a class="post-tag" href="/tags/docker/">docker</a> <a class="post-tag" href="/tags/pingora/">Pingora</a> <a class="post-tag" href="/tags/posix/">POSIX</a> <a class="post-tag" href="/tags/%E5%8F%8C%E7%B3%BB%E7%BB%9F/">双系统</a> <a class="post-tag" href="/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA/">虚拟机</a> <a class="post-tag" href="/tags/android%E6%9D%83%E9%99%90/">android权限</a> <a class="post-tag" href="/tags/aosp/">aosp</a> <a class="post-tag" href="/tags/archlinux/">archlinux</a></div></div></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><footer><div class="container pl-lg-4 pr-lg-4"><div class="d-flex justify-content-between align-items-center text-muted ml-md-3 mr-md-3"><div class="footer-left"><p class="mb-0"> © 2026 <a href="https://blog.algs.tech">blog.algs.tech</a>. <span data-toggle="tooltip" data-placement="top" title="除非另有说明，本网站上的博客文章均由作者按照知识共享署名 4.0 国际 (CC BY 4.0) 许可协议进行授权。">保留部分权利。</span></p></div><div class="footer-right"><p class="mb-0">本站由 <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> 生成，采用 <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> 主题。</p></div></div></div></footer><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a><div id="notification" class="toast" role="alert" aria-live="assertive" aria-atomic="true" data-animation="true" data-autohide="false"><div class="toast-header"> <button type="button" class="ml-2 ml-auto close" data-dismiss="toast" aria-label="Close"> <span aria-hidden="true">&times;</span> </button></div><div class="toast-body text-center pt-0"><p class="pl-2 pr-2 mb-3">发现新版本的内容。</p><button type="button" class="btn btn-primary" aria-label="Update"> 更新 </button></div></div><script src="/assets/dist/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">搜索结果为空</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script src="/assets/dist/jquery.magnific-popup.min.js"></script> <script src="/assets/dist/lazysizes.min.js"></script> <script src="/assets/dist/clipboard.min.js"></script> <script src="/assets/dist/dayjs.min.js"></script> <script src="/assets/dist/locale/zh.min.js"></script> <script src="/assets/dist/relativeTime.min.js"></script> <script src="/assets/dist/localizedFormat.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script src="/assets/dist/bootstrap.bundle.min.js"></script> <script defer src="/app.js"></script>
