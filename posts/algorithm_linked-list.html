<!DOCTYPE html><html lang="zh-CN" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="theme-color" media="(prefers-color-scheme: light)" content="#f7f7f7"><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1b1b1e"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"><meta name="viewport" content="width=device-width, user-scalable=no initial-scale=1, shrink-to-fit=no, viewport-fit=cover" ><meta name="generator" content="Jekyll v4.4.1" /><meta property="og:title" content="数据结构中的线性离散存储-链表" /><meta property="og:locale" content="zh_CN" /><meta name="description" content="撰写时间：2019-06-28，整理时间：2023-01-26" /><meta property="og:description" content="撰写时间：2019-06-28，整理时间：2023-01-26" /><link rel="canonical" href="https://blog.algs.tech/posts/algorithm_linked-list.html" /><meta property="og:url" content="https://blog.algs.tech/posts/algorithm_linked-list.html" /><meta property="og:site_name" content="极客开发者-博客" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2023-01-26T21:35:00+08:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="数据结构中的线性离散存储-链表" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2023-01-26T21:35:00+08:00","datePublished":"2023-01-26T21:35:00+08:00","description":"撰写时间：2019-06-28，整理时间：2023-01-26","headline":"数据结构中的线性离散存储-链表","mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.algs.tech/posts/algorithm_linked-list.html"},"url":"https://blog.algs.tech/posts/algorithm_linked-list.html"}</script><title>数据结构中的线性离散存储-链表 | 极客开发者-博客</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="极客开发者-博客"><meta name="application-name" content="极客开发者-博客"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="stylesheet" href="/assets/dist/fonts/main.css"><link rel="stylesheet" href="/assets/dist/bootstrap.min.css"><link rel="stylesheet" href="/assets/dist/fontawesome.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="/assets/lib/tocbot/tocbot.min.css"><link rel="stylesheet" href="/assets/dist/magnific-popup.min.css"> <script src="/assets/dist/jquery.min.js"></script> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get MODE_ATTR() { return "data-mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } static get ID() { return "mode-toggle"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } let self = this; /* always follow the system prefers */ this.sysDarkPrefers.addEventListener('change', () => { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.notify(); }); } /* constructor() */ get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode === ModeToggle.DARK_MODE; } get isLightMode() { return this.mode === ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer)) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } setDark() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_ATTR); sessionStorage.removeItem(ModeToggle.MODE_KEY); } /* Notify another plugins that the theme mode has changed */ notify() { window.postMessage({ direction: ModeToggle.ID, message: this.modeStatus }, "*"); } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } this.notify(); } /* flipMode() */ } /* ModeToggle */ const modeToggle = new ModeToggle(); </script><body data-topbar-visible="true"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" class="mx-auto"> <img src="/img/about/avatar.jpeg" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title"> <a href="/">极客开发者-博客</a></div><div class="site-subtitle font-italic">在探索未知与梦想的道路上，让我们拥有共同的称呼 -- 开发者</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>首页</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>分类</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tag ml-xl-3 mr-xl-3 unloaded"></i> <span>标签</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>归档</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info-circle ml-xl-3 mr-xl-3 unloaded"></i> <span>关于</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center align-items-center"> <button class="mode-toggle btn" aria-label="Switch Mode"> <i class="fas fa-adjust"></i> </button> <span class="icon-border"></span> <a href="https://github.com/geekdex" aria-label="github" target="_blank" rel="noopener noreferrer"> <i class="fab fa-github"></i> </a> <a href="javascript:location.href = 'mailto:' + ['pan.hy','foxmail.com'].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" > <i class="fas fa-rss"></i> </a></div></div><div id="topbar-wrapper"><div id="topbar" class="container d-flex align-items-center justify-content-between h-100 pl-3 pr-3 pl-md-4 pr-md-4"> <span id="breadcrumb"> <span> <a href="/"> 首页 </a> </span> <span>数据结构中的线性离散存储-链表</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> 文章</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="搜索..."> </span> <span id="search-cancel" >取消</span></div></div><div id="main-wrapper" class="d-flex justify-content-center"><div id="main" class="container pl-xl-4 pr-xl-4"><div class="row"><div id="core-wrapper" class="col-12 col-lg-11 col-xl-9 pr-xl-4"><div class="post pl-1 pr-1 pl-md-2 pr-md-2"><h1 data-toc-skip>数据结构中的线性离散存储-链表</h1><div class="post-meta text-muted"> <span> 发表于 <em class="" data-ts="1674740100" data-df="YYYY/MM/DD" data-toggle="tooltip" data-placement="bottom"> 2023/01/26 </em> </span> <span style="float: right;"> <a href="https://lab.aoco.tech/convert?url=https://raw.githubusercontent.com/geekdex/blog/refs/heads/main/_posts/2023-01-26-algorithm_linked-list.md" class="view-source" target="_blank" style="color: #2a5caa; text-decoration: none; font-weight: 500;"> 查看Codelabs </a> &nbsp;|&nbsp; <a href="https://github.com/geekdex/blog/blob/main/_posts/2023-01-26-algorithm_linked-list.md" class="view-source" target="_blank" style="color: #2a5caa; text-decoration: none; font-weight: 500;"> 查看源码 </a> </span><div class="d-flex justify-content-between"> <span> 作者 <em> <a href="https://blog.algs.tech">blog.algs.tech</a> </em> </span><div> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="3692 字"> <em>20 分钟</em>阅读</span></div></div></div><div class="post-content"><blockquote><p>撰写时间：2019-06-28，整理时间：2023-01-26</p></blockquote><h2 id="一概述"><span class="mr-2">一、概述</span><a href="#一概述" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>在上节，我们已经了解到了线性存储中的连续存储，我们还把这种存储结构叫做顺序表，或者数组。并且知道线性连续存储存在以下优缺点</p><ul><li>优点：能实现快速追加和存取元素<li>缺点：插入元素或删除元素都要移动大量的原有元素</ul><p>在本节，我们将一起来了解《数据结构》中研究的另一种线性数据结构-离散存储，我们也可以把线性的离散存储叫做链表。链表的基本结构如下图：</p><p><a href="/img/algorithm/04-01.png" class="popup img-link "><img data-src="/img/algorithm/04-01.png" alt="02-1.png" class="lazyload" data-proofer-ignore></a></p><p>如果你没有阅读过本系列的前面部门文章，建议您通过以下链接先阅读之前的内容，从线性连续存储开始，重新认识《数据结构》 <a href="/posts/algorithm-linear-list/">https://blog.jiker.dev/posts/algorithm-linear-list/</a>**</p><h2 id="二链表的实现过程"><span class="mr-2">二、链表的实现过程</span><a href="#二链表的实现过程" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><h3 id="21-定义链表节点"><span class="mr-2">2.1 定义链表节点</span><a href="#21-定义链表节点" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>和顺序表相比，链表的存储结构在实现插入、删除时，不需要移动大量的元素。但不容易实现随机存取元素线性表中第i个元素的操作。所以链表适用于需要经常进行插入和删除的操作的线性表，如飞机航班乘客表。</p><p>首先我们定义一个<code class="language-plaintext highlighter-rouge">02-LinkList.cpp</code>文件，需要引入基本的c语言头文件，并且定义链表节点的结构体</p><div class="language-cpp highlighter-rouge"><div class="code-header"> <span data-label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre><span class="cp"># include &lt;stdio.h&gt; // 标准io头部，包含printf函数
# include &lt;malloc.h&gt; // 包含malloc函数，在mac电脑上，改为sys/malloc.h
# include &lt;stdlib.h&gt; // 包含exit函数
</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="nc">Node</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">data</span><span class="p">;</span>           <span class="c1">// 数据域</span>
    <span class="k">struct</span> <span class="nc">Node</span> <span class="o">*</span><span class="n">pNext</span><span class="p">;</span> <span class="c1">// 指针域</span>
<span class="p">}</span> <span class="n">NODE</span><span class="p">,</span> <span class="o">*</span><span class="n">PNODE</span><span class="p">;</span>         <span class="c1">// NODE 等价于 struct Node, *PNODE 等价于* Node</span>
</pre></table></code></div></div><h3 id="22-创建链表"><span class="mr-2">2.2 创建链表</span><a href="#22-创建链表" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>接下来我们定义创建链表的函数</p><div class="language-cpp highlighter-rouge"><div class="code-header"> <span data-label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
</pre><td class="rouge-code"><pre><span class="n">PNODE</span> <span class="nf">create_list</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">len</span><span class="p">;</span> <span class="c1">// 存放节点的有效个数</span>
    <span class="kt">int</span> <span class="n">val</span><span class="p">;</span> <span class="c1">//存放用户输入的临时存入的节点的值</span>

    <span class="c1">// 分配一个不存在任何数据的头节点</span>
    <span class="n">PNODE</span> <span class="n">pHead</span> <span class="o">=</span> <span class="p">(</span><span class="n">PNODE</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">NODE</span><span class="p">));</span>
    <span class="k">if</span> <span class="p">(</span><span class="nb">NULL</span> <span class="o">==</span> <span class="n">pHead</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"内存分配失败!</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="n">exit</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c1">// 初始状态下，链表尾节点和头节点指向同一个内存（即头节点就是尾节点），而指针域为NULL</span>
    <span class="n">PNODE</span> <span class="n">pTail</span> <span class="o">=</span> <span class="n">pHead</span><span class="p">;</span>
    <span class="n">pTail</span><span class="o">-&gt;</span><span class="n">pNext</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

    <span class="n">printf</span><span class="p">(</span><span class="s">"请输入您需要生成的链表节点的个数：len="</span><span class="p">);</span>
    <span class="n">scanf</span><span class="p">(</span><span class="s">"%d"</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">len</span><span class="p">);</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"请输入第%d个节点的值"</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
        <span class="n">scanf</span><span class="p">(</span><span class="s">"%d"</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">val</span><span class="p">);</span>

        <span class="n">PNODE</span> <span class="n">pNew</span> <span class="o">=</span> <span class="p">(</span><span class="n">PNODE</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">NODE</span><span class="p">));</span>
        <span class="k">if</span> <span class="p">(</span><span class="nb">NULL</span> <span class="o">==</span> <span class="n">pNew</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">printf</span><span class="p">(</span><span class="s">"分配失败，程序终止！</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
            <span class="n">exit</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="c1">// 分配成功，给新节点赋值</span>
        <span class="n">pNew</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>
        <span class="c1">// 让链表尾节指针域点指向最新的节点，实现增加新节点</span>
        <span class="n">pTail</span><span class="o">-&gt;</span><span class="n">pNext</span> <span class="o">=</span> <span class="n">pNew</span><span class="p">;</span>
        <span class="c1">// 新节点的指针域为NULL</span>
        <span class="n">pNew</span><span class="o">-&gt;</span><span class="n">pNext</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

        <span class="c1">// 最后，再让尾节点指向新节点。</span>
        <span class="n">pTail</span> <span class="o">=</span> <span class="n">pNew</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// 链表创建完成后，返回头节点</span>
    <span class="k">return</span> <span class="n">pHead</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><h3 id="23-遍历链表元素"><span class="mr-2">2.3 遍历链表元素</span><a href="#23-遍历链表元素" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>从头节点开始，如果链表节点的指针域不为NULL，即输出数据</p><div class="language-cpp highlighter-rouge"><div class="code-header"> <span data-label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre><td class="rouge-code"><pre><span class="kt">void</span> <span class="nf">traverse_list</span><span class="p">(</span><span class="n">PNODE</span> <span class="n">pHead</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// 把第一个节点赋给变量p</span>
    <span class="n">PNODE</span> <span class="n">p</span> <span class="o">=</span> <span class="n">pHead</span><span class="o">-&gt;</span><span class="n">pNext</span><span class="p">;</span>

    <span class="k">while</span> <span class="p">(</span><span class="nb">NULL</span> <span class="o">!=</span> <span class="n">p</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">// p 不为NULL,代表有数据，则输出p的数据于</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"%d  "</span><span class="p">,</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">);</span>
        <span class="c1">// 输出p的数据域之后，让p指向下一个节点</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">pNext</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="k">return</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><h3 id="24-判断链表是否为空和计算链表长度"><span class="mr-2">2.4 判断链表是否为空和计算链表长度</span><a href="#24-判断链表是否为空和计算链表长度" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>如果链表头节点的指针域为空，则链表是空链表。长度的计算则通过遍历链表来计算，如下代码</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
</pre><td class="rouge-code"><pre><span class="c1">// 判断链表是否为空</span>
<span class="n">bool</span> <span class="nf">is_empty</span><span class="p">(</span><span class="n">PNODE</span> <span class="n">pHead</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="nb">NULL</span> <span class="o">==</span> <span class="n">pHead</span><span class="o">-&gt;</span><span class="n">pNext</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">else</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// 计算链表的长度</span>
<span class="kt">int</span> <span class="nf">length_list</span><span class="p">(</span><span class="n">PNODE</span> <span class="n">pHead</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">PNODE</span> <span class="n">p</span> <span class="o">=</span> <span class="n">pHead</span><span class="o">-&gt;</span><span class="n">pNext</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="nb">NULL</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="o">++</span><span class="n">len</span><span class="p">;</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">pNext</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">len</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><h3 id="25-链表排序"><span class="mr-2">2.5 链表排序</span><a href="#25-链表排序" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>接下来，我们根据从小到大的数据域值对链表节点进行排序。链表的排序和顺序表类似，我们使用两个节点变量用于临时存储对比中的两个节点，如下代码</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
</pre><td class="rouge-code"><pre><span class="c1">// 链表排序</span>
<span class="kt">void</span> <span class="nf">sort_list</span><span class="p">(</span><span class="n">PNODE</span> <span class="n">pHead</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">t</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="n">length_list</span><span class="p">(</span><span class="n">pHead</span><span class="p">);</span>
    <span class="c1">// 定义p和q两个节点变量，用于临时存放交换节点</span>
    <span class="n">PNODE</span> <span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">;</span>

    <span class="c1">// 让p指向当前节点</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">p</span> <span class="o">=</span> <span class="n">pHead</span><span class="o">-&gt;</span><span class="n">pNext</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">,</span> <span class="n">p</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">pNext</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">// 让q指向下一个节点</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">q</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">pNext</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">,</span> <span class="n">q</span> <span class="o">=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">pNext</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="c1">// 用当前节点和下一个节点进行对比，如果当前节点的数据域大于下一个节点，就将数据进行交换</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">&gt;</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="n">t</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
                <span class="n">p</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
                <span class="n">q</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">=</span> <span class="n">t</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><h3 id="26-插入新节点"><span class="mr-2">2.6 插入新节点</span><a href="#26-插入新节点" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>在接下来的插入和删除操作中，我们记链表的索引为position，position从0开始。首先，在链表的position位置插入节点，该节点的值是val，代码如下</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
</pre><td class="rouge-code"><pre><span class="c1">// 插入节点</span>
<span class="n">bool</span> <span class="nf">insert_list</span><span class="p">(</span><span class="n">PNODE</span> <span class="n">pHead</span><span class="p">,</span> <span class="kt">int</span> <span class="n">position</span><span class="p">,</span> <span class="kt">int</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="n">length_list</span><span class="p">(</span><span class="n">pHead</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">position</span> <span class="o">&gt;</span> <span class="n">len</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">PNODE</span> <span class="n">p</span> <span class="o">=</span> <span class="n">pHead</span><span class="p">;</span>
    <span class="c1">// 使用while循环，使p变量指向position节点的前一个节点</span>
    <span class="k">while</span> <span class="p">(</span><span class="nb">NULL</span> <span class="o">!=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">pNext</span> <span class="o">&amp;&amp;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">position</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">pNext</span><span class="p">;</span>
        <span class="o">++</span><span class="n">i</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// 程序执行到这里，p已经指向position节点的前一个节点，position节点是否为空无所谓</span>

    <span class="c1">// 插入过程1：分配新节点</span>
    <span class="n">PNODE</span> <span class="n">pNew</span> <span class="o">=</span> <span class="p">(</span><span class="n">PNODE</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">NODE</span><span class="p">));</span>
    <span class="k">if</span> <span class="p">(</span><span class="nb">NULL</span> <span class="o">==</span> <span class="n">pNew</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"动态分配内存失败失败"</span><span class="p">);</span>
        <span class="n">exit</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="c1">// 插入过程2：将传入的值赋给新节点的数据域</span>
    <span class="n">pNew</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>

    <span class="c1">// 插入过程3：用变量q临时存储position节点</span>
    <span class="n">PNODE</span> <span class="n">q</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">pNext</span><span class="p">;</span>
    <span class="c1">// 插入过程4：将position节点的前一个节点指向新节点</span>
    <span class="n">p</span><span class="o">-&gt;</span><span class="n">pNext</span> <span class="o">=</span> <span class="n">pNew</span><span class="p">;</span>
    <span class="c1">// 插入过程5：再将新节点指向posion节点</span>
    <span class="n">pNew</span><span class="o">-&gt;</span><span class="n">pNext</span> <span class="o">=</span> <span class="n">q</span><span class="p">;</span>

    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><h3 id="27-删除节点"><span class="mr-2">2.7 删除节点</span><a href="#27-删除节点" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>删除节点和插入节点操作类似。区别在于，插入节操作在找到position节点后，动态分配新空间并插入到原链表的position位置，删除节点操作则在找到position节点之后，释放position节点的空间，再把原position旁边两个不相连的节点连接起来。</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
</pre><td class="rouge-code"><pre><span class="c1">// 删除节点</span>
<span class="n">bool</span> <span class="nf">delete_list</span><span class="p">(</span><span class="n">PNODE</span> <span class="n">pHead</span><span class="p">,</span> <span class="kt">int</span> <span class="n">position</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">pVal</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="n">length_list</span><span class="p">(</span><span class="n">pHead</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">position</span> <span class="o">&gt;</span> <span class="n">len</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">PNODE</span> <span class="n">p</span> <span class="o">=</span> <span class="n">pHead</span><span class="p">;</span>

    <span class="c1">// 使用while循环，使p变量指向position节点的前一个节点</span>
    <span class="k">while</span> <span class="p">(</span><span class="nb">NULL</span> <span class="o">!=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">pNext</span> <span class="o">&amp;&amp;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">position</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">pNext</span><span class="p">;</span>
        <span class="o">++</span><span class="n">i</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// 如果position节点为NULL，返回false</span>
    <span class="k">if</span> <span class="p">(</span><span class="nb">NULL</span> <span class="o">==</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">pNext</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// 程序执行到这里，p已经指向position节点的前一个节点，并且position节点是存在的</span>
    <span class="c1">// 删除过程1，让q变量指向position节点</span>
    <span class="n">PNODE</span> <span class="n">q</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">pNext</span><span class="p">;</span>
    <span class="c1">// 删除过程2，将position节点的数据赋给pVal</span>
    <span class="o">*</span><span class="n">pVal</span> <span class="o">=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>

    <span class="c1">// 删除过程3，让position节点的前一个节点指向position节点的下一个</span>
    <span class="n">p</span><span class="o">-&gt;</span><span class="n">pNext</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">pNext</span><span class="o">-&gt;</span><span class="n">pNext</span><span class="p">;</span>

    <span class="c1">// 删除过程4，释放position节点指向的内存，并让q变量指向NULL</span>
    <span class="n">free</span><span class="p">(</span><span class="n">q</span><span class="p">);</span>
    <span class="n">q</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><h2 id="三测试与验证"><span class="mr-2">三、测试与验证</span><a href="#三测试与验证" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><h3 id="31-测试"><span class="mr-2">3.1 测试</span><a href="#31-测试" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>所有测试代码如下</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148
149
150
151
152
153
154
155
156
157
158
159
160
161
162
163
164
165
166
167
168
169
170
171
172
173
174
175
176
177
178
179
180
181
182
183
184
185
186
187
188
189
190
191
192
193
194
195
196
197
198
199
200
201
202
203
204
205
206
207
208
209
210
211
212
213
214
215
216
217
218
219
220
221
222
223
224
225
226
227
228
229
230
231
232
233
234
235
236
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;sys/malloc.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
</span>
<span class="c1">// 定义链表节点</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">Node</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">data</span><span class="p">;</span>           <span class="c1">// 数据域</span>
    <span class="k">struct</span> <span class="n">Node</span> <span class="o">*</span><span class="n">pNext</span><span class="p">;</span> <span class="c1">// 指针域</span>
<span class="p">}</span> <span class="n">NODE</span><span class="p">,</span> <span class="o">*</span><span class="n">PNODE</span><span class="p">;</span>         <span class="c1">// NODE 等价于 struct Node, *PNODE 等价于* Node</span>

<span class="c1">// 创建一个非循环的单链表</span>
<span class="n">PNODE</span> <span class="nf">create_list</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">len</span><span class="p">;</span> <span class="c1">// 存放节点的有效个数</span>
    <span class="kt">int</span> <span class="n">val</span><span class="p">;</span> <span class="c1">//存放用户输入的临时存入的节点的值</span>

    <span class="c1">// 分配一个不存在任何数据的头节点</span>
    <span class="n">PNODE</span> <span class="n">pHead</span> <span class="o">=</span> <span class="p">(</span><span class="n">PNODE</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">NODE</span><span class="p">));</span>
    <span class="k">if</span> <span class="p">(</span><span class="nb">NULL</span> <span class="o">==</span> <span class="n">pHead</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"内存分配失败!</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="n">exit</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c1">// 初始状态下，链表尾节点和头节点指向同一个内存（即头节点就是尾节点），而指针域为NULL</span>
    <span class="n">PNODE</span> <span class="n">pTail</span> <span class="o">=</span> <span class="n">pHead</span><span class="p">;</span>
    <span class="n">pTail</span><span class="o">-&gt;</span><span class="n">pNext</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

    <span class="n">printf</span><span class="p">(</span><span class="s">"请输入您需要生成的链表节点的个数：len="</span><span class="p">);</span>
    <span class="n">scanf</span><span class="p">(</span><span class="s">"%d"</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">len</span><span class="p">);</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"请输入第%d个节点的值:"</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
        <span class="n">scanf</span><span class="p">(</span><span class="s">"%d"</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">val</span><span class="p">);</span>

        <span class="n">PNODE</span> <span class="n">pNew</span> <span class="o">=</span> <span class="p">(</span><span class="n">PNODE</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">NODE</span><span class="p">));</span>
        <span class="k">if</span> <span class="p">(</span><span class="nb">NULL</span> <span class="o">==</span> <span class="n">pNew</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">printf</span><span class="p">(</span><span class="s">"分配失败，程序终止！</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
            <span class="n">exit</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="c1">// 分配成功，给新节点赋值</span>
        <span class="n">pNew</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>
        <span class="c1">// 让链表尾节指针域点指向最新的节点，实现增加新节点</span>
        <span class="n">pTail</span><span class="o">-&gt;</span><span class="n">pNext</span> <span class="o">=</span> <span class="n">pNew</span><span class="p">;</span>
        <span class="c1">// 新节点的指针域为NULL</span>
        <span class="n">pNew</span><span class="o">-&gt;</span><span class="n">pNext</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

        <span class="c1">// 最后，再让尾节点指向新节点。</span>
        <span class="n">pTail</span> <span class="o">=</span> <span class="n">pNew</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// 链表创建完成后，返回头节点</span>
    <span class="k">return</span> <span class="n">pHead</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// 遍历链表</span>
<span class="kt">void</span> <span class="nf">traverse_list</span><span class="p">(</span><span class="n">PNODE</span> <span class="n">pHead</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// 把第一个节点赋给变量p</span>
    <span class="n">PNODE</span> <span class="n">p</span> <span class="o">=</span> <span class="n">pHead</span><span class="o">-&gt;</span><span class="n">pNext</span><span class="p">;</span>

    <span class="k">while</span> <span class="p">(</span><span class="nb">NULL</span> <span class="o">!=</span> <span class="n">p</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">// p 不为NULL,代表有数据，则输出p的数据于</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"%d  "</span><span class="p">,</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">);</span>
        <span class="c1">// 输出p的数据域之后，让p指向下一个节点</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">pNext</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// 判断链表是否为空</span>
<span class="n">bool</span> <span class="nf">is_empty</span><span class="p">(</span><span class="n">PNODE</span> <span class="n">pHead</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="nb">NULL</span> <span class="o">==</span> <span class="n">pHead</span><span class="o">-&gt;</span><span class="n">pNext</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">else</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// 计算链表的长度</span>
<span class="kt">int</span> <span class="nf">length_list</span><span class="p">(</span><span class="n">PNODE</span> <span class="n">pHead</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">PNODE</span> <span class="n">p</span> <span class="o">=</span> <span class="n">pHead</span><span class="o">-&gt;</span><span class="n">pNext</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="nb">NULL</span> <span class="o">!=</span> <span class="n">p</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="o">++</span><span class="n">len</span><span class="p">;</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">pNext</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">len</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// 链表排序</span>
<span class="kt">void</span> <span class="nf">sort_list</span><span class="p">(</span><span class="n">PNODE</span> <span class="n">pHead</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">t</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="n">length_list</span><span class="p">(</span><span class="n">pHead</span><span class="p">);</span>
    <span class="c1">// 定义p和q两个节点变量，用于临时存放交换节点</span>
    <span class="n">PNODE</span> <span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">;</span>

    <span class="c1">// 让p指向当前节点</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">p</span> <span class="o">=</span> <span class="n">pHead</span><span class="o">-&gt;</span><span class="n">pNext</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">len</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">,</span> <span class="n">p</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">pNext</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">// 让q指向当前节点的下一个节点</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">q</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">pNext</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">,</span> <span class="n">q</span> <span class="o">=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">pNext</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="c1">// 用当前节点和下一个节点进行对比，如果当前节点的数据域大于下一个节点，就将数据进行交换</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">&gt;</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="n">t</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
                <span class="n">p</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
                <span class="n">q</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">=</span> <span class="n">t</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// 插入节点</span>
<span class="n">bool</span> <span class="nf">insert_list</span><span class="p">(</span><span class="n">PNODE</span> <span class="n">pHead</span><span class="p">,</span> <span class="kt">int</span> <span class="n">position</span><span class="p">,</span> <span class="kt">int</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="n">length_list</span><span class="p">(</span><span class="n">pHead</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">position</span> <span class="o">&gt;</span> <span class="n">len</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">PNODE</span> <span class="n">p</span> <span class="o">=</span> <span class="n">pHead</span><span class="p">;</span>
    <span class="c1">// 使用while循环，使p变量指向position节点的前一个节点</span>
    <span class="k">while</span> <span class="p">(</span><span class="nb">NULL</span> <span class="o">!=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">pNext</span> <span class="o">&amp;&amp;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">position</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">pNext</span><span class="p">;</span>
        <span class="o">++</span><span class="n">i</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// 程序执行到这里，p已经指向position节点的前一个节点，position节点是否为空无所谓</span>

    <span class="c1">// 插入过程1：分配新节点</span>
    <span class="n">PNODE</span> <span class="n">pNew</span> <span class="o">=</span> <span class="p">(</span><span class="n">PNODE</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">NODE</span><span class="p">));</span>
    <span class="k">if</span> <span class="p">(</span><span class="nb">NULL</span> <span class="o">==</span> <span class="n">pNew</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"动态分配内存失败失败"</span><span class="p">);</span>
        <span class="n">exit</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="c1">// 插入过程2：将传入的值赋给新节点的数据域</span>
    <span class="n">pNew</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>

    <span class="c1">// 插入过程3：用变量q临时存储position节点</span>
    <span class="n">PNODE</span> <span class="n">q</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">pNext</span><span class="p">;</span>
    <span class="c1">// 插入过程4：将position节点的前一个节点指向新节点</span>
    <span class="n">p</span><span class="o">-&gt;</span><span class="n">pNext</span> <span class="o">=</span> <span class="n">pNew</span><span class="p">;</span>
    <span class="c1">// 插入过程5：再将新节点指向posion节点</span>
    <span class="n">pNew</span><span class="o">-&gt;</span><span class="n">pNext</span> <span class="o">=</span> <span class="n">q</span><span class="p">;</span>

    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// 删除节点</span>
<span class="n">bool</span> <span class="nf">delete_list</span><span class="p">(</span><span class="n">PNODE</span> <span class="n">pHead</span><span class="p">,</span> <span class="kt">int</span> <span class="n">position</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">pVal</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="n">length_list</span><span class="p">(</span><span class="n">pHead</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">position</span> <span class="o">&gt;</span> <span class="n">len</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">PNODE</span> <span class="n">p</span> <span class="o">=</span> <span class="n">pHead</span><span class="p">;</span>

    <span class="c1">// 使用while循环，使p变量指向position节点的前一个节点</span>
    <span class="k">while</span> <span class="p">(</span><span class="nb">NULL</span> <span class="o">!=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">pNext</span> <span class="o">&amp;&amp;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">position</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">pNext</span><span class="p">;</span>
        <span class="o">++</span><span class="n">i</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// 如果position节点为NULL，返回false</span>
    <span class="k">if</span> <span class="p">(</span><span class="nb">NULL</span> <span class="o">==</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">pNext</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// 程序执行到这里，p已经指向position节点的前一个节点，并且position节点是存在的</span>
    <span class="c1">// 删除过程1，让q变量指向position节点</span>
    <span class="n">PNODE</span> <span class="n">q</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">pNext</span><span class="p">;</span>
    <span class="c1">// 删除过程2，将position节点的数据赋给pVal</span>
    <span class="o">*</span><span class="n">pVal</span> <span class="o">=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>

    <span class="c1">// 删除过程3，让position节点的前一个节点指向position节点的下一个</span>
    <span class="n">p</span><span class="o">-&gt;</span><span class="n">pNext</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">pNext</span><span class="o">-&gt;</span><span class="n">pNext</span><span class="p">;</span>

    <span class="c1">// 删除过程4，释放position节点指向的内存，并让q变量指向NULL</span>
    <span class="n">free</span><span class="p">(</span><span class="n">q</span><span class="p">);</span>
    <span class="n">q</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="c1">// 创建链表，定义长度为6，输入1、5、6、4、3、2</span>
    <span class="n">PNODE</span> <span class="n">pHead</span> <span class="o">=</span> <span class="n">create_list</span><span class="p">();</span>

    <span class="c1">// 遍历元素：输出 1 5 6 4 3 2</span>
    <span class="n">traverse_list</span><span class="p">(</span><span class="n">pHead</span><span class="p">);</span>

    <span class="c1">// 链表排序</span>
    <span class="n">sort_list</span><span class="p">(</span><span class="n">pHead</span><span class="p">);</span>
    <span class="c1">// 遍历元素：输出 1 2 3 4 5 6</span>
    <span class="n">traverse_list</span><span class="p">(</span><span class="n">pHead</span><span class="p">);</span>

    <span class="c1">// 在索引为0的位置添加元素7</span>
    <span class="n">insert_list</span><span class="p">(</span><span class="n">pHead</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">7</span><span class="p">);</span>
    <span class="c1">// 遍历元素：输出 7 1 2 3 4 5 6</span>
    <span class="n">traverse_list</span><span class="p">(</span><span class="n">pHead</span><span class="p">);</span>

    <span class="c1">// 在索引为5的位置删除元素，并输出删除的元素</span>
    <span class="kt">int</span> <span class="n">val</span><span class="p">;</span>
    <span class="n">delete_list</span><span class="p">(</span><span class="n">pHead</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">val</span><span class="p">);</span>
    <span class="c1">// 遍历元素，输出：</span>
    <span class="n">traverse_list</span><span class="p">(</span><span class="n">pHead</span><span class="p">);</span>
    <span class="c1">// 打印删除的元素</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"被删除的元素数据域是%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><h3 id="32-结果"><span class="mr-2">3.2 结果</span><a href="#32-结果" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>程序编译与执行的结果如下</p><div class="language-text highlighter-rouge"><div class="code-header"> <span data-label-text="Text"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre><td class="rouge-code"><pre>pan@pandeMBP ds % g++ 02-LinkList.cpp
pan@pandeMBP ds % ./a.out 
请输入您需要生成的链表节点的个数：len=6
请输入第1个节点的值:1
请输入第2个节点的值:5
请输入第3个节点的值:6
请输入第4个节点的值:4
请输入第5个节点的值:3
请输入第6个节点的值:2
1  5  6  4  3  2  
1  2  3  4  5  6  
7  1  2  3  4  5  6  
7  1  2  3  4  6  
被删除的元素数据域是5
</pre></table></code></div></div><blockquote><p>本文原创首发自wx订阅号：<strong>极客开发中</strong>，禁止转载</p></blockquote></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/'>数据结构与算法</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> 本文由作者按照 <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> 进行授权</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">分享</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%AD%E7%9A%84%E7%BA%BF%E6%80%A7%E7%A6%BB%E6%95%A3%E5%AD%98%E5%82%A8-%E9%93%BE%E8%A1%A8%20-%20%E6%9E%81%E5%AE%A2%E5%BC%80%E5%8F%91%E8%80%85-%E5%8D%9A%E5%AE%A2&url=https%3A%2F%2Fblog.algs.tech%2Fposts%2Falgorithm_linked-list.html" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%AD%E7%9A%84%E7%BA%BF%E6%80%A7%E7%A6%BB%E6%95%A3%E5%AD%98%E5%82%A8-%E9%93%BE%E8%A1%A8%20-%20%E6%9E%81%E5%AE%A2%E5%BC%80%E5%8F%91%E8%80%85-%E5%8D%9A%E5%AE%A2&u=https%3A%2F%2Fblog.algs.tech%2Fposts%2Falgorithm_linked-list.html" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://t.me/share/url?url=https%3A%2F%2Fblog.algs.tech%2Fposts%2Falgorithm_linked-list.html&text=%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%AD%E7%9A%84%E7%BA%BF%E6%80%A7%E7%A6%BB%E6%95%A3%E5%AD%98%E5%82%A8-%E9%93%BE%E8%A1%A8%20-%20%E6%9E%81%E5%AE%A2%E5%BC%80%E5%8F%91%E8%80%85-%E5%8D%9A%E5%AE%A2" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <a href="https://service.weibo.com/share/share.php?title=%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%AD%E7%9A%84%E7%BA%BF%E6%80%A7%E7%A6%BB%E6%95%A3%E5%AD%98%E5%82%A8-%E9%93%BE%E8%A1%A8%20-%20%E6%9E%81%E5%AE%A2%E5%BC%80%E5%8F%91%E8%80%85-%E5%8D%9A%E5%AE%A2&url=https%3A%2F%2Fblog.algs.tech%2Fposts%2Falgorithm_linked-list.html" data-toggle="tooltip" data-placement="top" title="Weibo" target="_blank" rel="noopener" aria-label="Weibo"> <i class="fa-fw fab fa-weibo"></i> </a> <i id="copy-link" class="fa-fw fas fa-link small" data-toggle="tooltip" data-placement="top" title="分享链接" data-title-succeed="链接已复制！"> </i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted"><div class="access"><div id="access-tags"><div class="panel-heading">热门标签</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/k8s/">k8s</a> <a class="post-tag" href="/tags/adb/">adb</a> <a class="post-tag" href="/tags/docker/">docker</a> <a class="post-tag" href="/tags/pingora/">Pingora</a> <a class="post-tag" href="/tags/posix/">POSIX</a> <a class="post-tag" href="/tags/%E5%8F%8C%E7%B3%BB%E7%BB%9F/">双系统</a> <a class="post-tag" href="/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA/">虚拟机</a> <a class="post-tag" href="/tags/android%E6%9D%83%E9%99%90/">android权限</a> <a class="post-tag" href="/tags/aosp/">aosp</a> <a class="post-tag" href="/tags/archlinux/">archlinux</a></div></div></div><div id="toc-wrapper" class="pl-0 pr-4 mb-5"><div class="panel-heading pl-3 pt-2 mb-2">文章内容</div><nav id="toc"></nav></div><script src="/assets/lib/tocbot/tocbot.min.js"></script></div></div><div class="row"><div id="tail-wrapper" class="col-12 col-lg-11 col-xl-9 pl-3 pr-3 pr-xl-4 mt-5"><div id="related-posts" class="mb-2 mb-sm-4"><h3 class="pt-2 mb-4 ml-1" data-toc-skip>相关文章</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/algorithm_statement.html"><div class="card-body"> <em class="small" data-ts="1674048060" data-df="YYYY/MM/DD" > 2023/01/18 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>算法学习基础-基本概念</h3><div class="text-muted small"><p> 一、概述 撰写时间：2019-06-07 13:35，整理时间：2023-01-18 作为一名普通的二本学校，我在很早之前就有一个目标，那就是大学之后好好找一个软件开发工作。因此学习了很多的编程基础，不过近几天面试发现，技术官总是喜欢问你算法知识。编程语言不断变化，但是很底层的知识与算法密切相关，算法也就是体现程序员内功所在。因此，从此该好好学算法。 本笔记参考马士兵老师...</p></div></div></a></div><div class="card"> <a href="/posts/algorithm_sort.html"><div class="card-body"> <em class="small" data-ts="1674739620" data-df="YYYY/MM/DD" > 2023/01/26 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>算法学习基础-排序问题</h3><div class="text-muted small"><p> 撰写时间：2019-06-09，整理时间：2023-01-26，此博客参考以下内容 https://www.bilibili.com/video/av46648286 一、什么是排序问题？ 一系列没有顺序的数，从大到小或者从小到大进行排序，这就是排序问题。排序问题是最简单，最容易考到的问题。常见的排序如下图 我们应该至少记住四种排序，如下图 二、排序算法宋词记忆法 ...</p></div></div></a></div><div class="card"> <a href="/posts/algorithm_linear-list.html"><div class="card-body"> <em class="small" data-ts="1674739680" data-df="YYYY/MM/DD" > 2023/01/26 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>从线性连续存储开始，重新认识《数据结构》</h3><div class="text-muted small"><p> 撰写时间：2019-06-13，整理时间：2023-01-26 一、数据结构概述 1.1 简介 《数据结构》这门课程大多时候等同于《数据结构与算法》，所以我们一般说数据结构，都会涉及到算法。《数据结构》这门课程要求学生根据所学的数据结构理论，能完成复杂的程序设计。而程序设计能力的提高，必须要有学习、观摩、借鉴和实践的过程。 在阅读这篇文章时，你应当具备一定的C/C++编程基础...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/algorithm_linear-list.html" class="btn btn-outline-primary" prompt="上一篇"><p>从线性连续存储开始，重新认识《数据结构》</p></a> <a href="/posts/android_android6-permition.html" class="btn btn-outline-primary" prompt="下一篇"><p>Android 6.0以上动态申请文件读写权限</p></a></div><script type="text/javascript"> $(function () { const origin = "https://giscus.app"; const iframe = "iframe.giscus-frame"; const lightTheme = "light"; const darkTheme = "dark_dimmed"; let initTheme = lightTheme; if ($("html[data-mode=dark]").length > 0 || ($("html[data-mode]").length == 0 && window.matchMedia("(prefers-color-scheme: dark)").matches)) { initTheme = darkTheme; } let giscusAttributes = { "src": "https://giscus.app/client.js", "data-repo": "geekdex/blog", "data-repo-id": "R_kgDOIyxhcQ", "data-category": "General", "data-category-id": "DIC_kwDOIyxhcc4CUhya", "data-mapping": "pathname", "data-reactions-enabled": "anonymous", "data-emit-metadata": "0", "data-theme": initTheme, "data-input-position": "0", "data-lang": "zh-CN", "crossorigin": "anonymous", "async": "" }; let giscusScript = document.createElement("script"); Object.entries(giscusAttributes).forEach(([key, value]) => giscusScript.setAttribute(key, value)); document.getElementById("tail-wrapper").appendChild(giscusScript); addEventListener("message", (event) => { if (event.source === window && event.data && event.data.direction === ModeToggle.ID) { /* global theme mode changed */ const mode = event.data.message; const theme = (mode === ModeToggle.DARK_MODE ? darkTheme : lightTheme); const message = { setConfig: { theme: theme } }; const giscus = document.querySelector(iframe).contentWindow; giscus.postMessage({ giscus: message }, origin); } }); }); </script></div></div></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><div id="access-tags"><div class="panel-heading">热门标签</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/k8s/">k8s</a> <a class="post-tag" href="/tags/adb/">adb</a> <a class="post-tag" href="/tags/docker/">docker</a> <a class="post-tag" href="/tags/pingora/">Pingora</a> <a class="post-tag" href="/tags/posix/">POSIX</a> <a class="post-tag" href="/tags/%E5%8F%8C%E7%B3%BB%E7%BB%9F/">双系统</a> <a class="post-tag" href="/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA/">虚拟机</a> <a class="post-tag" href="/tags/android%E6%9D%83%E9%99%90/">android权限</a> <a class="post-tag" href="/tags/aosp/">aosp</a> <a class="post-tag" href="/tags/archlinux/">archlinux</a></div></div></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><footer><div class="container pl-lg-4 pr-lg-4"><div class="d-flex justify-content-between align-items-center text-muted ml-md-3 mr-md-3"><div class="footer-left"><p class="mb-0"> © 2026 <a href="https://blog.algs.tech">blog.algs.tech</a>. <span data-toggle="tooltip" data-placement="top" title="除非另有说明，本网站上的博客文章均由作者按照知识共享署名 4.0 国际 (CC BY 4.0) 许可协议进行授权。">保留部分权利。</span></p></div><div class="footer-right"><p class="mb-0">本站由 <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> 生成，采用 <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> 主题。</p></div></div></div></footer><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a><div id="notification" class="toast" role="alert" aria-live="assertive" aria-atomic="true" data-animation="true" data-autohide="false"><div class="toast-header"> <button type="button" class="ml-2 ml-auto close" data-dismiss="toast" aria-label="Close"> <span aria-hidden="true">&times;</span> </button></div><div class="toast-body text-center pt-0"><p class="pl-2 pr-2 mb-3">发现新版本的内容。</p><button type="button" class="btn btn-primary" aria-label="Update"> 更新 </button></div></div><script src="/assets/dist/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">搜索结果为空</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script src="/assets/dist/jquery.magnific-popup.min.js"></script> <script src="/assets/dist/lazysizes.min.js"></script> <script src="/assets/dist/clipboard.min.js"></script> <script src="/assets/dist/dayjs.min.js"></script> <script src="/assets/dist/locale/zh.min.js"></script> <script src="/assets/dist/relativeTime.min.js"></script> <script src="/assets/dist/localizedFormat.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script src="/assets/dist/bootstrap.bundle.min.js"></script> <script defer src="/app.js"></script>
